<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>如何在应用层控制最大客户端连接 - 狂想曲</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=狂想曲 rel=home><div class="logo__item logo__text"><div class=logo__title>狂想曲</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>如何在应用层控制最大客户端连接</h1></header><div class="content post__content clearfix"><p>当有客户端连接, 而程序中没有去处理时, select 就回持续不断的返回这个文件描述符可写, 例如, 下面是我以前写的一段有 bug 的程序:</p><pre><code>int csocks[MAX_CONNECTION];
memset(csocks, -1, MAX_CONNECTION * sizeof(int));

FD_SET(sock, &amp;rset);
while(1) {
    if (select(FD_SETSIZE, &amp;rset, NULL, NULL, NULL) &lt;= 0) {
        return ;
    }
    if (FD_ISSET(sock, &amp;rset)) {
        // looking for an unused socket
        for (int i = 0 ; i &lt; MAX_CONNECTION; ++i) {
            if((-1 == csocks[i]) &amp;&amp; (-1 != (csocks[i] = accept(sock, NULL, NULL))))
                break;
        }
    }
}
</code></pre><p>这段程序里, sock 是一个侦听套接字, 负责侦听客户端的连接, 一有连接就会去调用 accept 来接受客户端的连接 &mdash; 当然, 这是有条件的, 那就是能够接收的最大的客户端数量是 MAX_CONNECTION, 由上面的程序里可以看到, 当连接的客户端的数量已经超过了 MAX_CONNECTION 时, 将不会再接受任何连接.</p><p>然后上面的代码有一个潜在的问题, 那就是, 当客户端连接满了, csocks 数组已经没有为 -1 的元素了, 那么新的连接到达时, accept 将永远不会被调用. 似乎没有问题是吗? 不, 问题很严重, accept 永远不会被调用的话, select 调用会知道 sock 文件描述符没有被你读过, 那么下一次 while 循环时, select 将会再次成功返回以表明 sock 文件描述符可读.</p><p>这是灾难性的, 你可以想象, 一个 while 循环, 里面 select 调用飞速的执行, 返回, 执行, 返回&mldr;.</p><p>这是 select 调用的行为, 其实在串口通信, 普通文件读写时也是这样的情况: 当你用 select 监听一个串口文件, 当串口有数据到达, 但是你就是不去读取的话, 那么之后不管你调用多少次 selelct 调用, 它都会返回正数, 同时表明你传递的串口文件的描述符可以读.</p><p>回到最初的问题, 那么, 我们想要限制客户端连接的数量, 那么用上面的方法可不行, 当客户端数量到达了我们应用程序里设定的最大数目, 当新的客户端连接到达时, 我们也不能仅仅就是简单的不去 accept 它 &mdash; 它会一直在那里, 下一次 select 会再次告诉你它在那里.</p><p>那么到底怎么做呢, 我们总得处理一下, 首先我们要告诉 select 调用, 这个新的客户端连接请求我已经处理过了, 下一次你就不用再把这个客户端的连接请求报告我了. 其次, 我们最好向这个新客户端返回一个 RESET 消息.</p><p><strong>Update:</strong></p><p>这个问题, 我已经在 stackoverflow 上提问并得到了答案: <a href=http://stackoverflow.com/questions/23379029/how-to-deny-clients-connection-properly-in-socket-programming/23379631#23379631>http://stackoverflow.com/questions/23379029/how-to-deny-clients-connection-properly-in-socket-programming/23379631#23379631</a></p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/c/ rel=tag>C</a></li></ul></div></footer></article></main><section class=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//justforfree.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 狂想曲.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>
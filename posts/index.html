<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Posts - 编程笔记</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml href=/posts/index.xml title=编程笔记><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=编程笔记 rel=home><div class="logo__item logo__text"><div class=logo__title>编程笔记</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class="main list" role=main><header class=main__header><h1 class=main__title>Posts</h1></header><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/year-in-review-2020/ rel=bookmark>2020 年终总结</a></h2></header><div class="content list__excerpt post__content clearfix">2020 年终总结 个人性格 始终还是优柔寡断的性格, 2021 年一定要改变这个性格. 工作 对管理有了一些思考, 一个管理者应该具备真正的资源把控能力, 而不应该单纯的就是派活给团队成员, 更不应该是 &ldquo;拿着鞭子&rd
</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/rust-singleton/ rel=bookmark>Rust 里的单例模式</a></h2></header><div class="content list__excerpt post__content clearfix">Rust 要想搞个单例模式还真是曲折. 单例模式说到底就是全局变量, 在别的语言很容易实现, 但是在 rust 里则诸多不便, 因为 rust 这门语言从设计上就是要避免使用全局变量的. 实际上 Rust 里就没有全局变量的概念, 只有生命周期的概念</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/aws-redis-cluster/ rel=bookmark>AWS Implementation of Redis Cluster</a></h2></header><div class="content list__excerpt post__content clearfix">AWS redis cluster topology Refer to [2]
Number of connections to master and slave nodes For each node there are two connection related metrics: NewConnections and CurrConnections.
NewConnections, AWS ElastiCache derives this by subtracting two consecutive samples of the total_connections_received stats of a redis node. CurrConnections, this metric is derived directly from the redis stats connected_clients which contains the number of client connections(excluding the connections from replicas) Redirect > Normally slave nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use slaves in order to scale reads using theREADONLY command.</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/browser-tracking/ rel=bookmark>浏览器追踪技术与防范</a></h2></header><div class="content list__excerpt post__content clearfix">Cookie 这里说的就是我们通常所熟知的 cookie，很多第三方公司就是借助这种 cookie 实现追踪的。比如网站 A，B 都使用了 DoubleClick 的 js 脚本，DoubleClick 的脚本在用户访问网站 A 时被加载并埋下 cookie，下次用户访</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/jit/ rel=bookmark>对解释器与 JIT 的一点思考</a></h2></header><div class="content list__excerpt post__content clearfix">我一直知道解释器与编译器的区别. 编译器是事先将代码编译成机器码, 然后直接送进内存让 cpu 执行, 解释器则是解释执行代码, 可能会将代码先转换成一种中间码, 但我一直有一个误区就是解释器在解释执行的时候会把源代码</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/coroutine/ rel=bookmark>对协程的一点认识</a></h2></header><div class="content list__excerpt post__content clearfix">协程的调度 我们知道线程是 CPU 的基本调度单元，线程调度靠的是时钟中断. 协程是执行于线程之内的更细粒度的执行单元，他的调度无法依赖时钟中断，而是要靠一个用户态的调度器，这个调度器可以是抢占式或非抢占式，抢占</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/dpos/ rel=bookmark>DPoS 核心概念</a></h2></header><div class="content list__excerpt post__content clearfix">本文基于 BM 的唯二的两篇阐述 DPoS 机制的文章, 第一篇文章是 BM 首次提出 DPoS 共识机制, 第二篇是 BM 后来对 DPoS 机制补充的白皮书. 两篇文章的链接见文末. 最近精读了这两篇文章, 从中提炼出了以下我认为是最核心的内容. 见证人选</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/c-plus-plus-reference/ rel=bookmark>C++ 的左右值与左右值引用</a></h2></header><div class="content list__excerpt post__content clearfix">左值与右值 C++ 中左值和右值的概念来源于 C, 在 C 中左值和右值的区别很简单, 能出现在赋值号左侧的就是左值, 否则就是右值. 比如变量是左值, 字面常量或者 const 定义的常量是右值. 然而在 C++ 中, 左值和右值的区别就不再是那么</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/controlling-client-connections/ rel=bookmark>如何在应用层控制最大客户端连接</a></h2></header><div class="content list__excerpt post__content clearfix">当有客户端连接, 而程序中没有去处理时, select 就回持续不断的返回这个文件描述符可写, 例如, 下面是我以前写的一段有 bug 的程序: int csocks[MAX_CONNECTION]; memset(csocks, -1, MAX_CONNECTION * sizeof(int)); FD_SET(sock, &rset); while(1) { if (select(FD_SETSIZE, &rset, NULL, NULL, NULL) &lt;= 0) { return ; } if (FD_ISSET(sock, &rset)) { // looking for an unused socket for (int i = 0 ; i &lt; MAX_CONNECTION;</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/c-macro/ rel=bookmark>C 语言宏的展开与字符串化宏和符号连接宏</a></h2></header><div class="content list__excerpt post__content clearfix">C 语言由于没什么高级的特性, 所以现有的特性被玩的各种精. 宏展开就是很值得品味的部分. 递归展开问题 宏定义语句是这样的: #define identifier token-sequence 在具体的宏展开过程中, 遇到标识符时, 此标识符会整个的被使用 token-sequence 展开, 如果 token-sequence 中还包</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/bitcoin-multisig/ rel=bookmark>比特币的多重签名技术与实践</a></h2></header><div class="content list__excerpt post__content clearfix">Multisignature scripts set a condition where N public keys are recorded in the script and at least M of those must provide signatures to unlock the funds. This is also known as an M-of-N scheme, where N is the total number of keys and M is the threshold of signatures required for validation &lt;精通比特币> 多重签名首次规范化提出是在 BIP11, 它添加了一种新的交易类型 OP_CHECKMULTISIG, 这种交易的锁定</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/bitcoin-currency/ rel=bookmark>论铸币制度与比特币多中心化</a></h2></header><div class="content list__excerpt post__content clearfix">货币起源 在人类文明发展史上, 由于物物交换的不便而产生了一般等价物, 金银等金属由于其不易损耗而又能够分割并重熔的特性成为备受认可的一般等价物 &mdash; 货币. 铸币制产生 金属作为货币并没有改变贝壳, 石头作为货币时的</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/year-in-review-2017/ rel=bookmark>2017 年终总结</a></h2></header><div class="content list__excerpt post__content clearfix">学习 学会了使用 python 写简单的工具 从盛科辞职, 加入了滴滴 研究数字货币, 研究的很深. 投资了 HPB, BTS 和 STEEM 人生 结婚 在一沿海二线城市买了方, 买的时候已经不便宜了 浪费时间的瞎折腾 emacs, orgmode 为了使用 orgmode, 不得不学习折腾 emacs, 要是早点发现</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/bitcoin-coinjoin/ rel=bookmark>比特币隐私加固 - CoinJoin 技术简析</a></h2></header><div class="content list__excerpt post__content clearfix">思想 由 @gmaxwell 在 CoinJoin: Bitcoin privacy for the real world 一文提出. 核心思想就是利用比特币的一笔交易中可以有多个输入以及多个输出这一点, 将多笔交易合并, 使得让人难以分辨哪笔输入对应哪笔输出, 进而达到难以追踪某个地址的资金的来源或去向的</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/python-time-datetime/ rel=bookmark>关于 Python 中的 time 与 datetime 模块</a></h2></header><div class="content list__excerpt post__content clearfix">在 Python 中处理时间有两个库可用: time 和 datetime, 这两个模块曾经在很长一段时间里困扰着我, 我觉得这是 Python 又一处矛盾的地方 (最大的矛盾是 3 和 2 不兼容), 因为一门对开发者友好的语言应该直接提供最好用的库, 而不是让开发者去做</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/knowledge-management/ rel=bookmark>再论个人知识管理</a></h2></header><div class="content list__excerpt post__content clearfix"></div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/freertos-vlistinsertend/ rel=bookmark>FreeRTOS 的链表 vListInsertEnd() 方法笔记</a></h2></header><div class="content list__excerpt post__content clearfix">在研究 FreeRTOS 内核时, 发现自已一直理解错了 vListInsertEnd() 的意思, 特此记录下. vListInsertEnd() 这个方法比较迷惑人, 这个方法真正的意思是尾插, 而不是插到链表的尾部. 这两者的意思是不一样的. 那究竟什么是尾插呢? 我们应该知道头插, 给定一个链</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/cgi-fastcgi-php-fpm/ rel=bookmark>通俗地解释 CGI, FastCGI, php-fpm 之间的关系</a></h2></header><div class="content list__excerpt post__content clearfix">这要了解一点万维网 (WWW) 的历史, 才能更好地了解个中关系. 早期的网站基本都是静态的, 那时候的 web server 几乎所有工作就是给访问者提供静态资源, 网站与访问者之间缺乏交互. 后来随着 WWW 的发展网站变得交互性强了起来, 交互性</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/bitcoin-on-off-chain/ rel=bookmark>什么是比特币的链上 (on-chain) 与链下 (off-chain) 交易, 以及往交易所充币后发生了什么</a></h2></header><div class="content list__excerpt post__content clearfix">on-chain on-chain 就是比特币的常规交易方式: 给我一个比特币地址 (公钥), 我用客户端创建交易发送比特币给你, 这笔交易在全网广播, 被确认, 被打包进区块. 显然, 交易是直接发生在链上的. off-chain 至于 off-chain 其实玩过比特币的人也都用过,</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/io-programming/ rel=bookmark>深入解读同步/异步 IO 编程模型</a></h2></header><div class="content list__excerpt post__content clearfix">所谓 &ldquo;同步&rdquo; 和 &ldquo;异步&rdquo; 是从调用者的角度来说的. 如果调用者不得不等待 IO 完成才能执行后续的工作, 那就是同步; 否则, 就是异步. 这是我对 &ldquo;同步&rd
</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/bitcoin-replay/ rel=bookmark>说一说重放, 重放保护, 以及分叉期间我们该怎么做</a></h2></header><div class="content list__excerpt post__content clearfix">何为重放 先说重放, 重放指的是分叉过后, 由于新链和旧链所运行的协议可能完全兼容, 导致在旧链上发生的交易拿到新链上也是合法的. 以本次的即将上演的 BTC/BTG 分叉为例: 在高度 A 左右我们生成了两个新地址 a, b. 然后在高度 B</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/segwit2x/ rel=bookmark>闲聊即将到来的 segwit2x 分叉</a></h2></header><div class="content list__excerpt post__content clearfix">早些时候由矿工主导的 &ldquo;纽约共识&rdquo; 达成了 segwit2x 方案, 约定在 2017 年 9 月以前启动隔离见证, 并在随后的 3 - 6 个月内启动 2mb 扩容. 所以 segwit2x 这个名字起的有意思, 看着好像跟 segwit 2.0 版一样, 实际上 segwit2x 指包含两</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/electrum-sweep/ rel=bookmark>Electrum 钱包的 sweep 功能小记</a></h2></header><div class="content list__excerpt post__content clearfix">electrum 是款优秀的 bitcoin 轻钱包, bitcoin.org 的文章里经常有提到它, 可见 bitcoin.org 除了自己的 core 钱包之外还是比较推荐 electrum 的. 使用 electrum 钱包时, 建议的生成私钥的方式是从 seed 生成, 这样所有生成的密钥都是可以从 seed 推算出来的, 对钱包的备份也就简化为</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/bitshares-account-mechanism/ rel=bookmark>Bitshares 中的账户与权限个人理解</a></h2></header><div class="content list__excerpt post__content clearfix">单一账户模型 在这个模型下, 我们提供一个登录名以及密码, 系统会根据登录名+密码生成确定的私钥, 所以用这种模式创建的账户, 可以在任何设备上用登录名+密码登录. 钱包模型 钱包模型的好处是, 钱包可以包含多个账户</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/what-is-bitcoin-address-how-to-protect-it/ rel=bookmark>比特币地址, 公钥与私钥的格式以及如何保证比特币不丢失</a></h2></header><div class="content list__excerpt post__content clearfix">我们知道在公钥加密体系中, 由私钥推出公钥很容易反过来却是不可能的, 借助一些伟大的数学算法可以实现这一特性, 比特币使用的算法叫做椭圆曲线算法. 在比特币中私钥就是一个 256bit 的数字, 得到这个数字的方法有很多, 最</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/compilers-of-solidity/ rel=bookmark>Solidity 的编译器们</a></h2></header><div class="content list__excerpt post__content clearfix">solidity 是当下 ethereum 最流行的智能合约开发语言, 语法类似于 javascript. 要使用它写智能合约的话, 我们还需要一个编译器, 用来将 solidity 的代码编译为 EVM 字节码. solidity 的编译器有多种实现, 下面可以一起看一看. solc 一般说到 solc 指的都是 ethereum 官方实现的 cpp</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/year-in-review-2016/ rel=bookmark>2016 年终总结</a></h2></header><div class="content list__excerpt post__content clearfix">这是一篇拖了相当久的总结, 2016 年是我动荡不安的一年. 辞职 首先是 6 月份的辞职, 这是我在 Y 工作整整三年来的辞职. 那个时候我的脑中存在着不知从哪听到的一个观念: 三年是一个阶段, 在一家公司工作满三年了就可以跳槽</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/acquired-by-didi/ rel=bookmark>写在入职滴滴的前夕</a></h2></header><div class="content list__excerpt post__content clearfix">明天 (3.21) 就正式入职滴滴了, 这对我来说是非常值得开心的, 然而我这些天却越发的感觉到几丝迷茫. 现在想想, 从上了大学起, 我精神就一直处于一个懒散的状态, 整个大学里没有一点危机意识, 没有去思考我该做什么, 想要什</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/a-problem-ryu-indigo-conn-setup/ rel=bookmark>记一次 Indigo 与 Ryu 的连接建立问题</a></h2></header><div class="content list__excerpt post__content clearfix">之前在研究 Indigo 和 Ryu 的衔接时碰到一个 OpenFlow 连接建立失败的问题, 特此记录下, 希望能够供别人参考. 在了解这个问题之前, 我们先回顾一下 OpenFlow 连接建立过程. OpenFlow 协议的连接建立过程 根据 OpenFlow 协议标准的陈述我们能够知道, 交换机和控</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/binary-tree-traversal/ rel=bookmark>二叉树递归遍历的本质以及用迭代遍历精确模拟递归遍历</a></h2></header><div class="content list__excerpt post__content clearfix">递归遍历是实现深度优先遍历的既直观又简单的方式, 二叉树递归遍历的本质其实就是在不断的压栈与出栈, 明白了这一道理之后就很容易借助栈结构来将递归遍历转换成迭代遍历. void traverse(struct TreeNode *root) { if (root) { /* 1 */ traverse(root->left); /* 2 */ traverse(root->right); /* 3 */ }</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/openflow-instruction-action/ rel=bookmark>关于 OpenFlow 协议中 Instruction, Action 概念的解读</a></h2></header><div class="content list__excerpt post__content clearfix">(首发于 sdnlab: http://www.sdnlab.com/17952.html) 阅读任何一个协议都要注意的一点是这个协议中所定义的专有术语, 对这些术语的理解不到位的话也会造成对协议的理解偏差. 本文想和大家分享几个可能容易混淆的术语. 在 OpenFlow 协议文档中经常会看到这么几个词语</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/c-volatile/ rel=bookmark>(译) 如何使用 C 语言中的 volatile 关键字</a></h2></header><div class="content list__excerpt post__content clearfix">(原文: http://www.barrgroup.com/Embedded-Systems/How-To/C-Volatile-Keyword, 已取得翻译许可) 很多 C 程序员都不真正懂得 volatile 关键字的用法. 这无需奇怪, 因为大多数的 C 教程对 volatile 的介绍都比较简单. 这篇文章的目的就是告诉你 volatile 的正确使用方式 你有碰到过下面的几个情形吗? 代码编译运行没</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/pam-su-wheel-group/ rel=bookmark>PAM, su 以及 wheel 用户组</a></h2></header><div class="content list__excerpt post__content clearfix">在我的 gentoo 系统下, su 使用 pam 模组, 要求只有处于 wheel 用户组的普通用户才能够使用 su 切换到 root 用户的权限. 如果你查看 /etc/pam.d/su, 可以看到下面这一行: auth required pam_wheel.so use_uid 但是 GNU su 不支持 wheel 用户组, 也就是说, 如果你使用的是 GNU su, 那么当你 (普通用</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/openocd-and-openjtag/ rel=bookmark>openocd 基础与百问网的 openjtag 介绍</a></h2></header><div class="content list__excerpt post__content clearfix">使用 openocd 的话, 最好是先看看 openocd 的官方手册, 100 多页, 不需要全看, 但是基本, 核心的概念要了解, 比如说 debug adapter/adapter, interface, target, board 等. Adapter 与 Interface 配置文件 debug adapter 或者直接叫做 adapter 呢, 就是指的你所使用的调试适配器, 一般来说就是 jtag 适配器了, 它会</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/php-pear-pecl/ rel=bookmark>PEAR 与 PECL 介绍</a></h2></header><div class="content list__excerpt post__content clearfix">PEAR PEAR 全称是 PHP Extension and Application Repository, 和水果 &ldquo;梨&rdquo; 的英文发音是相同的. PEAR 存在的目的是: 提供一个有组织结构的开源代码仓库给 PHP 用户们 提供一个代码发布以及包维护的系统 制定一份 PHP 代码风格规范 (在这里: http://pear.php.net/manual/en/standards.php)</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/pathinfo-and-nginx/ rel=bookmark>Pathinfo 和 Nginx</a></h2></header><div class="content list__excerpt post__content clearfix">不知为何, Nginx 中配置 PATH_INFO 似乎一直以来是一件不那么明朗的事情, 在网上搜索的话, 会搜到各种各样的配置方式. 很多都是网友们自己 &ldquo;发明&rdquo; 的. 各大发行版安装好了 Nginx 之后, 默认也是没有配置对 PATH_INFO 的</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/howto-detect-file-exists/ rel=bookmark>Linux C 中如何正确的判断一个文件/目录文件是否存在</a></h2></header><div class="content list__excerpt post__content clearfix">source: http://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c-cross-platform 其实不光是在 Linux 下编程, 在其他平台下我们都会有这样的需求: 我们要为应用程序创建自己的数据或者日志目录, 应用程序在每次启动时会检查文件系统中是否已经有了自己的目录, 没有的话就创建它, 有了的话就跳过这一</div></article><article class="list__item post"><header class=list__header><h2 class="list__title post__title"><a href=/posts/work-through-raid-in-rhel/ rel=bookmark>搞定 HP MicroServer 的 Smart Array Controller B120i 磁盘阵列, 在安装 RHEL 时</a></h2></header><div class="content list__excerpt post__content clearfix">MicroServer Gen8 是 HP 服务器里较新的一个系列, 其所配备的磁盘阵列卡 &mdash; Smart Array Controller B120i, 也是比较新的一种阵列卡, 目前 HP 仅提供了 RHEL, OpenSUSE, Microsoft 的驱动程序. 我们就是要在 MicroServer Gen8 上安装 RHEL6. MicroServer Gen8 的主板上的 ROM 上搭在了一个小型的配置系统, 叫做 Intelligence Provisioning, 在这里</div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 编程笔记.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>
<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>AWS Implementation of Redis Cluster</title><link rel=stylesheet href=/css/style.css></head><body><header><a href=https://cifer97.github.io>编程笔记</a></header><main><article><h1>AWS Implementation of Redis Cluster</h1><time>2020.04.05</time><div><h2 id=aws-redis-cluster-topology>AWS redis cluster topology</h2><p>Refer to [2]</p><h2 id=number-of-connections-to-master-and-slave-nodes>Number of connections to master and slave nodes</h2><p>For each node there are two connection related metrics: NewConnections and CurrConnections.</p><ul><li>NewConnections, AWS ElastiCache derives this by subtracting two consecutive samples of the total_connections_received stats of a redis node.</li><li>CurrConnections, this metric is derived directly from the redis stats connected_clients which contains the number of client connections(excluding the connections from replicas)</li></ul><h2 id=redirect>Redirect</h2><p>> Normally slave nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use slaves in order to scale reads using the<a href=https://redis.io/commands/readonly> READONLY</a> command.</p><p><a href=https://aws.amazon.com/premiumsupport/knowledge-center/elasticache-redis-client-readonly/>Learn Why Redis Client Read Requests Are Read From or Redirected to the Master Node of a Shard</a></p><h2 id=go-redis-source-code>Go-redis source code</h2><p>Code path: github.com/go-redis/redis/cluster.go</p><p><strong>Entities</strong></p><ul><li><p>ClusterClient</p><ul><li>opt *ClusterOptions</li><li>nodes *clusterNodes</li><li>state *clusterStateHolder</li><li>process func(Cmder) error</li></ul></li><li><p>ClusterOptions</p><ul><li>Addrs []string</li><li>MaxRedirects int</li><li>ReadOnly bool</li><li>RouteByLatency bool</li><li>PoolSize int</li></ul></li><li><p>clusterNodes</p><ul><li>allAddrs []string</li><li>allNodes map[string]*clusterNode</li></ul></li><li><p>clusterNode</p><ul><li>Client Client (Including connPool)</li></ul></li><li><p>clusterStateHolder</p><ul><li>load func() (*clusterState, error)</li><li>State atomic.Value (-> *clusterState)</li></ul></li><li><p>clusterState</p></li></ul><p><img src=topo.png alt=img></p><p><strong>Procedure</strong></p><ul><li><p>Cluster client initialization</p></li><li><ul><li>ClusterOptions is passed to initialization the ClusterClient, in our case, the <code>Addrs</code> option is the AWS elasticache upfront domain address</li><li>The elasticache upfront address is stored in <code>clusterNodes.allAddrs</code> as the only address</li></ul></li><li><p>State construction - during the first time a redis cmd is called</p></li><li><ul><li><p>-> (*clusterStateHolder).Get() -> (*clusterStateHolder).Reload() -> (*clusterStateHolder).load()</p></li><li><p>-> traverse (*clusterNodes).allAddrs, in our case only the elasticache upfront address, pick this addr to create the clusterNode object and connect to that node</p></li><li><ul><li>Note elasticache upfront address could resolve to anyone of the ip addresses behind it, that doesn’t matter. Go-redis will use whatever it returns to get the full snapshot of the redis cluster</li></ul></li><li><p>-> a new clusterNode accompanied with a new client: -> NewClient() -> newConnPool() (means there will be multiple connections but up to poolSize established to each cluster node)</p></li><li><p>-> retrieve all slots info through the new connected clusterNode by using the <code>cluster slots</code> cmd(this is the recommended way by redis official[3])</p></li><li><p>Creates clusterNodes and connects to each node returned in the slots. Also maintains the relationships of slot -> clusterNodes</p></li></ul></li><li><p>Connection Pool</p></li><li><ul><li>Each clusterNode object represents a client to the corresponding cluster node</li><li>Each client in go-redis maintains a connection pool to the corresponding cluster node</li></ul></li><li><p>Cmd flow after state construction:</p></li><li><ul><li><p>-> (*ClusterClient).process(Cmder)</p></li><li><p>-> (*ClusterClient).cmdSlotAndNode(Cmder) calculate slot and choose the corresponding node</p></li><li><ul><li>If readonly enabled, prioritarily choose the slave node under that slot</li><li>Otherwise choose master node (this is why master nodes usually get more connections than slave nodes)</li></ul></li><li><p>Find a clusterNode by calling (*ClusterClient).cmdSlotAndNode(Cmder). This method ensures the correct node of the slot is returned.</p></li></ul></li></ul><h2 id=references>References</h2><ol><li><a href=https://redis.io/topics/cluster-spec>Redis Cluster Specification</a></li><li>Scaling Your Redis Workloads with Redis Cluster: <a href=https://youtu.be/3Ovx5vJ17ws>https://youtu.be/3Ovx5vJ17ws</a></li><li><a href=https://redis.io/topics/cluster-spec#clients-first-connection-and-handling-of-redirections>https://redis.io/topics/cluster-spec#clients-first-connection-and-handling-of-redirections</a></li></ol></div><div><ul id=tags><li><a href=/tags/redis>redis</a></li><li><a href=/tags/aws>aws</a></li></ul></div></article></main><footer><p>&copy; 2021 <a href=https://cifer97.github.io>编程笔记</a></p></footer></body></html>
<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Cifer"><title>AWS Implementation of Redis Cluster ｜ 编程笔记</title><meta name=description content="AWS redis cluster topology Refer to [2]
Number of connections to master and slave nodes For each node there are two connection related metrics: NewConnections and CurrConnections.
 NewConnections, AWS ElastiCache derives this by subtracting two consecutive samples of the total_connections_received stats of a redis node. CurrConnections, this metric is derived directly from the redis stats connected_clients which contains the number of client connections(excluding the connections from replicas)  Redirect &amp;gt; Normally slave nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use slaves in order to scale reads using theREADONLY command."><link rel="shortcut icon" href=https://cifer97.github.io/images/favicon.ico><link rel=stylesheet type=text/css media=screen href=https://cifer97.github.iocss/normalize.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css><link rel=stylesheet type=text/css media=screen href=https://cifer97.github.io/css/zozo.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css><link rel=stylesheet type=text/css media=screen href=https://cifer97.github.io/css/highlight.css></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul></ul></div><div class=menu_icon><a id=menu_icon><i class=ri-menu-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=https://cifer97.github.io><span>编程笔记</span></a></h1></div><div class=description><p class=sub_title></p><div class=my_socials><a href=https://cifer97.github.io/index.xml type=application/rss+xml title=rss target=_blank><i class=ri-rss-fill></i></a></div></div></div></div><div class=content><div class=post_page><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><h2><a href=/posts/aws-redis-cluster/>AWS Implementation of Redis Cluster</a></h2><span class=date>2020.05.04</span></div><div class="post_content markdown"><h2 id=aws-redis-cluster-topology>AWS redis cluster topology</h2><p>Refer to [2]</p><h2 id=number-of-connections-to-master-and-slave-nodes>Number of connections to master and slave nodes</h2><p>For each node there are two connection related metrics: NewConnections and CurrConnections.</p><ul><li>NewConnections, AWS ElastiCache derives this by subtracting two consecutive samples of the total_connections_received stats of a redis node.</li><li>CurrConnections, this metric is derived directly from the redis stats connected_clients which contains the number of client connections(excluding the connections from replicas)</li></ul><h2 id=redirect>Redirect</h2><p>> Normally slave nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use slaves in order to scale reads using the<a href=https://redis.io/commands/readonly> READONLY</a> command.</p><p><a href=https://aws.amazon.com/premiumsupport/knowledge-center/elasticache-redis-client-readonly/>Learn Why Redis Client Read Requests Are Read From or Redirected to the Master Node of a Shard</a></p><h2 id=go-redis-source-code>Go-redis source code</h2><p>Code path: github.com/go-redis/redis/cluster.go</p><p><strong>Entities</strong></p><ul><li><p>ClusterClient</p><ul><li>opt *ClusterOptions</li><li>nodes *clusterNodes</li><li>state *clusterStateHolder</li><li>process func(Cmder) error</li></ul></li><li><p>ClusterOptions</p><ul><li>Addrs []string</li><li>MaxRedirects int</li><li>ReadOnly bool</li><li>RouteByLatency bool</li><li>PoolSize int</li></ul></li><li><p>clusterNodes</p><ul><li>allAddrs []string</li><li>allNodes map[string]*clusterNode</li></ul></li><li><p>clusterNode</p><ul><li>Client Client (Including connPool)</li></ul></li><li><p>clusterStateHolder</p><ul><li>load func() (*clusterState, error)</li><li>State atomic.Value (-> *clusterState)</li></ul></li><li><p>clusterState</p></li></ul><p><img src=topo.png alt=img></p><p><strong>Procedure</strong></p><ul><li><p>Cluster client initialization</p></li><li><ul><li>ClusterOptions is passed to initialization the ClusterClient, in our case, the <code>Addrs</code> option is the AWS elasticache upfront domain address</li><li>The elasticache upfront address is stored in <code>clusterNodes.allAddrs</code> as the only address</li></ul></li><li><p>State construction - during the first time a redis cmd is called</p></li><li><ul><li><p>-> (*clusterStateHolder).Get() -> (*clusterStateHolder).Reload() -> (*clusterStateHolder).load()</p></li><li><p>-> traverse (*clusterNodes).allAddrs, in our case only the elasticache upfront address, pick this addr to create the clusterNode object and connect to that node</p></li><li><ul><li>Note elasticache upfront address could resolve to anyone of the ip addresses behind it, that doesn’t matter. Go-redis will use whatever it returns to get the full snapshot of the redis cluster</li></ul></li><li><p>-> a new clusterNode accompanied with a new client: -> NewClient() -> newConnPool() (means there will be multiple connections but up to poolSize established to each cluster node)</p></li><li><p>-> retrieve all slots info through the new connected clusterNode by using the <code>cluster slots</code> cmd(this is the recommended way by redis official[3])</p></li><li><p>Creates clusterNodes and connects to each node returned in the slots. Also maintains the relationships of slot -> clusterNodes</p></li></ul></li><li><p>Connection Pool</p></li><li><ul><li>Each clusterNode object represents a client to the corresponding cluster node</li><li>Each client in go-redis maintains a connection pool to the corresponding cluster node</li></ul></li><li><p>Cmd flow after state construction:</p></li><li><ul><li><p>-> (*ClusterClient).process(Cmder)</p></li><li><p>-> (*ClusterClient).cmdSlotAndNode(Cmder) calculate slot and choose the corresponding node</p></li><li><ul><li>If readonly enabled, prioritarily choose the slave node under that slot</li><li>Otherwise choose master node (this is why master nodes usually get more connections than slave nodes)</li></ul></li><li><p>Find a clusterNode by calling (*ClusterClient).cmdSlotAndNode(Cmder). This method ensures the correct node of the slot is returned.</p></li></ul></li></ul><h2 id=references>References</h2><ol><li><a href=https://redis.io/topics/cluster-spec>Redis Cluster Specification</a></li><li>Scaling Your Redis Workloads with Redis Cluster: <a href=https://youtu.be/3Ovx5vJ17ws>https://youtu.be/3Ovx5vJ17ws</a></li><li><a href=https://redis.io/topics/cluster-spec#clients-first-connection-and-handling-of-redirections>https://redis.io/topics/cluster-spec#clients-first-connection-and-handling-of-redirections</a></li></ol></div><div class=post_footer><div class=meta><div class=info><span class="field tags"><i class=ri-stack-line></i>
<a href=https://cifer97.github.io/tags/redis/>redis</a>
<a href=https://cifer97.github.io/tags/aws/>aws</a></span></div></div></div></div><div class=doc_comments></div></div></div></div><a id=back_to_top href=# class=back_to_top><i class=ri-arrow-up-s-line></i></a><footer class=footer><div class=powered_by><a href=https://varkai.com>Designed by VarKai,</a>
<a href=http://www.gohugo.io/>Proudly published with Hugo</a></div><div class=footer_slogan><span></span></div></footer><script src=https://cifer97.github.io/js/jquery-3.5.1.min.js></script><link href=https://cifer97.github.io/css/fancybox.min.css rel=stylesheet><script src=https://cifer97.github.io/js/fancybox.min.js></script><script src=https://cifer97.github.io/js/zozo.js></script></body></html>
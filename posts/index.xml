<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 编程笔记</title><link>https://cifer97.github.io/posts/</link><description>Recent content in Posts on 编程笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 07 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer97.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust 里的单例模式</title><link>https://cifer97.github.io/posts/rust-singleton/</link><pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/rust-singleton/</guid><description>Rust 要想搞个单例模式还真是曲折.
单例模式说到底就是全局变量, 在别的语言很容易实现, 但是在 rust 里则诸多不便, 因为 rust 这门语言从设计上就是要避免使用全局变量的. 实际上 Rust 里就没有全局变量的概念, 只有生命周期的概念, 全局变量某种意义上也就是具有整个运行时周期的静态变量, 如果我们真的要定义全局变量, 那就用 static 关键字. 后面我们姑且不论全局变量和静态变量的区别, 统一用静态变量的说法.
Rust 的 static 关键字和 C/C++ 语言一样, 代表变量的生命周期是整个运行时, 但是相比 C/C++ rust 的 static 有一个限制: 必须使用编译时期能够确定的值初始化. 刚看到着点有点想吐槽, 这不就跟 const 常量有点像了么, 不过一想这应该也是 rust 为了安全考虑, 防止运行时有多处地方想要初始化这个静态变量. 但是给我们造成的麻烦可就不小了, 具体麻烦程度取决于我们需不需随后在运行时修改这静态变量的值, 需要分别讨论.
如果我们运气好不需要运行时修改静态变量, 意味着变量声明不用加 mut, 那就很好, 虽然这种情况其实直接用 const 就行了&amp;hellip; 但总之看起来至此需求满足了, 讨论可以结束? 很遗憾并没有.
往往我们用单例模式都是要和系统资源打交道的, 比如网络连接, 文件描述符等, 这些系统资源当然本身是不支持同步访问的, 需要上层有一种机制保证对他们的访问是同步的. 对于 unmutable 的静态变量, rust 会编译时检查这个变量类型是否本身支持同步访问, 支持则已, 不支持则会报错. 不愧是 rust, 多么的严谨哦~ 那 rust 是怎么检查的呢?</description></item><item><title>关于 OpenFlow 协议中 Instruction, Action 概念的解读</title><link>https://cifer97.github.io/posts/openflow-instruction-action/</link><pubDate>Mon, 03 Oct 2016 21:45:30 +0000</pubDate><guid>https://cifer97.github.io/posts/openflow-instruction-action/</guid><description>(首发于 sdnlab: http://www.sdnlab.com/17952.html)
阅读任何一个协议都要注意的一点是这个协议中所定义的专有术语, 对这些术语的理解不到位的话也会造成对协议的理解偏差. 本文想和大家分享几个可能容易混淆的术语.
在 OpenFlow 协议文档中经常会看到这么几个词语: Instruction, Action, Apply-actions, Action Set, Action List, Clear-actions, &amp;hellip; 有点迷惑人, 实际上这里面只有两个实体的概念: Instruction 和 Action. 为了保持后文的易读性, 这两个概念分别用中文 &amp;ldquo;指令&amp;rdquo; 和 &amp;ldquo;动作&amp;rdquo; 来描述. 下文中的 &amp;ldquo;指令&amp;rdquo; 和 &amp;ldquo;动作&amp;rdquo; 都特指在 OpenFlow 协议中的含义.
指令这个词, 特指流表表项中的指令, 当某个报文匹配了这个表项之后, 表项中的指令就会被应用于这个报文; 而动作是比指令更细粒度的概念, 但它并不是局限于流表表项的概念, 动作可以独立于指令而存在, 也可以被包含在指令中, 具体说来, 我们在下流表的时候, 可以为某个表项的某种指令指定一些列的动作, 但是动作并不是只有下流表的时候才会被用到.
本文以目前较新的 Openflow 1.4 版本为准, 来分别看一下指令和动作的含义.
指令 每一个流表的表项都包含一系列的指令, 当报文匹配上了这个表项后, 这些指令就会被执行, 这些指令的执行结果有几种: 改变报文, 改变 action set, 改变 pipeline. 这些指令可以按照其执行结果的不同而分类, 不同的流表的表项包含的指令种类也不同, 前面说了指令可以包含动作, 但也并非所有种类的指令都包含动作, 下面我们一起来看一下指令的分类.
指令的分类 OpenFlow 1.</description></item><item><title>书单</title><link>https://cifer97.github.io/posts/books/</link><pubDate>Mon, 25 Jul 2016 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/books/</guid><description>2021 经济学原理 - 曼昆 聪明的投资者 - 格雷厄姆, 价值投资的鼻祖 伯克希尔年报 - 巴菲特 资本回报 - 马拉松基金 2020 and earlier Data Structures and Algorithm Analysis in C, 2nd edition The C Programming Language (aka. K &amp;amp; R C), 2nd edition, K &amp;amp; R C 第一版是 C 语言历史上的第一个 &amp;ldquo;事实标准&amp;rdquo;, 而这第二版则是在 ANSI C89 标准出来之后对第一版的修订, 目前在网上能够找到的也是这个版本. Expert C Programming, Deep Secrets See MIPS Run, 2nd edition, 少有的将处理器架构和操作系统结合起来讲的书, 而且作者的写作思想和我完全一致, 绝世好书! Using the FreeRTOS Real Time Kernel - Standard Edition, FreeRTOS 是一个实现非常精炼和优雅的实时操作系统内核, 这本官方的小书为我们展现了 FreeRTOS 内核的优美.</description></item><item><title>(译) 如何使用 C 语言中的 volatile 关键字</title><link>https://cifer97.github.io/posts/c-volatile/</link><pubDate>Sat, 07 Nov 2015 21:01:45 +0000</pubDate><guid>https://cifer97.github.io/posts/c-volatile/</guid><description>(原文: http://www.barrgroup.com/Embedded-Systems/How-To/C-Volatile-Keyword, 已取得翻译许可)
很多 C 程序员都不真正懂得 volatile 关键字的用法. 这无需奇怪, 因为大多数的 C 教程对 volatile 的介绍都比较简单. 这篇文章的目的就是告诉你 volatile 的正确使用方式
你有碰到过下面的几个情形吗?
代码编译运行没问题 &amp;mdash; 直到你打开了编译器优化 代码运行的很好 &amp;mdash; 直到一个中断发生 古怪的硬件驱动程序 RTOS task 各自单独运行时很好 &amp;mdash; 直到有其它 task 被 spawned 如果你碰到过上述任何一个问题, 那么就可能是你没有使用 volatile 关键字的原因. 你并不孤单, volatile 关键字为很多程序员所不熟悉. 不幸的是, 很多 C 相关的书籍都没有好好的介绍 volatile 关键字.
volatile 关键字和 const 一样, 是一个限定符, 用于一个变量被声明时. 它告诉编译器, 被声明的变量的值可能随时都会被改变 &amp;ndash; 就算使用这个变量的代码的附近 (附近有多近, 要看编译器了, 可能是同一个源文件) 没有任何修改这个变量值的语句也是如此. 给编译器的这个暗示是很严肃的, 在我们继续讲解之前, 我们先来看一下 volatile 的语法.
volatile 关键字的语法 要将一个变量声明为 volatile 的, 需要在声明时将 volatile 关键字写到数据类型关键字的前面或后面.</description></item><item><title>PEAR 与 PECL 介绍</title><link>https://cifer97.github.io/posts/php-pear-pecl/</link><pubDate>Mon, 09 Feb 2015 09:39:30 +0000</pubDate><guid>https://cifer97.github.io/posts/php-pear-pecl/</guid><description>PEAR PEAR 全称是 PHP Extension and Application Repository, 和水果 &amp;ldquo;梨&amp;rdquo; 的英文发音是相同的. PEAR 存在的目的是:
提供一个有组织结构的开源代码仓库给 PHP 用户们 提供一个代码发布以及包维护的系统 制定一份 PHP 代码风格规范 (在这里: http://pear.php.net/manual/en/standards.php) 运作 PHP Extension Community Lbrary (PECL) 姐妹组织 维护相关的网站, 邮件列表, 源镜像, PEAR/PECL 社区 PEAR 是一个社区驱动的组织, 由开发者管理. PEAR 的使命 PEAR 的使命就是为 PHP 用户提供良好可重用的组件 (避免让用户自造轮子), 以及领导 PHP 革新, 努力为 PHP 开发者提供最佳的开发体验.
由 PHP 书写的结构良好的代码库以及应用 PEAR 中的代码以 &amp;ldquo;包&amp;rdquo; 为单元. 每一个包都是一个独立维护的项目, 有专门的开发团队, 有自己的版本号, 发布周期, 项目文档, 以及与其他包的依赖关系信息.
PEAR 中的包都是以 gzip tar 档案格式发布的. 在你的系统上, 你可以使用 &amp;ldquo;PEAR installer&amp;rdquo; (http://pear.</description></item><item><title>Pathinfo 和 Nginx</title><link>https://cifer97.github.io/posts/pathinfo-and-nginx/</link><pubDate>Fri, 30 Jan 2015 16:27:31 +0000</pubDate><guid>https://cifer97.github.io/posts/pathinfo-and-nginx/</guid><description>不知为何, Nginx 中配置 PATH_INFO 似乎一直以来是一件不那么明朗的事情, 在网上搜索的话, 会搜到各种各样的配置方式. 很多都是网友们自己 &amp;ldquo;发明&amp;rdquo; 的. 各大发行版安装好了 Nginx 之后, 默认也是没有配置对 PATH_INFO 的支持的, 怎么会这样呢? 难道 Nginx 就没有一个官方的解决方案吗?
自然是有的.
PATH_INFO 是 CGI 1.1 标准中规定的一个变量, 在 www 服务器委托 CGI 脚本执行任务时, 需要传递给 CGI 脚本的信息. 这么重要的一个变量, Nginx 当然是会支持的. 参考一中就是官方的方案. 我们在这里重复一下.
首先我们知道, 在 nginx 中, 是可以使用 nginx 自带的一些命令, 给 CGI 1.1 中规定的那些变量赋值的, 而这些命令默认都位于 /etc/nginx/fastcgi.conf 或者 /etc/nginx/fastcgi_params 文件里, 在配置 fastcgi 程序处理我们的请求时, 只要在 nginx 中包含这个两个文件之一, fastcgi 程序就能够取得所需要的变量. 在我的系统上, /etc/nginx/fastcgi.conf 文件是这样的:
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_param REQUEST_URI $request_uri; fastcgi_param DOCUMENT_URI $document_uri; fastcgi_param DOCUMENT_ROOT $document_root; fastcgi_param SERVER_PROTOCOL $server_protocol; fastcgi_param HTTPS $https if_not_empty; fastcgi_param GATEWAY_INTERFACE CGI/1.</description></item><item><title>Linux C 中如何正确的判断一个文件/目录文件是否存在</title><link>https://cifer97.github.io/posts/howto-detect-file-exists/</link><pubDate>Sun, 06 Apr 2014 14:59:00 +0000</pubDate><guid>https://cifer97.github.io/posts/howto-detect-file-exists/</guid><description>source: http://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c-cross-platform
其实不光是在 Linux 下编程, 在其他平台下我们都会有这样的需求: 我们要为应用程序创建自己的数据或者日志目录, 应用程序在每次启动时会检查文件系统中是否已经有了自己的目录, 没有的话就创建它, 有了的话就跳过这一步. 那么如何去判断文件系统中是否已经存在了要创建的目录呢?
Linux 或者 GNU C 都没有提供一个像 file_exists() 这样直观的系统调用给我们, 所以我们得通过其它的调用来达成这个目标.
实际上当我第一次要解决这个问题时, 我先 google 了一下, 这个问题在 stackoverflow 上有人问过而且非常受欢迎, 很多人对这个问题又点赞又收藏的, 自然, 这个问题也收到了不少好的答案, 这篇文章算是对这些好答案的总结和延伸.
我们先来看一个大家都应该知道的方式, 第一种方式:
fopen() fopen() 方法是流阶级的方法, 这个方法接收用户提供的文件名, 以及访问方式, 然后尝试着打开文件, 打开成功则返回 handle, 失败则返回 NULL. 因此有人提出了使用这个方法来判断指定的文件是否存在的方案:
#include &amp;lt;stdio.h&amp;gt; ... FILE *fp = NULL; fp = fopen(&amp;quot;/tmp/test/somefile&amp;quot;, &amp;quot;r&amp;quot;); if(fp) { // exists } else { // not exists } fclose(fp); 这也是 stackoverflow 上唯一一个得负分的答案, 这个方案的问题在于它没有考虑到文件权限的问题, 而 fopen() 这个函数又是如此的简单 &amp;mdash; 不管因为什么原因打开文件失败了, 它只是返回 NULL 给你, 不会提供更多的错误信息.</description></item><item><title>搞定 HP MicroServer 的 Smart Array Controller B120i 磁盘阵列, 在安装 RHEL 时</title><link>https://cifer97.github.io/posts/work-through-raid-in-rhel/</link><pubDate>Wed, 22 Jan 2014 09:48:00 +0000</pubDate><guid>https://cifer97.github.io/posts/work-through-raid-in-rhel/</guid><description>MicroServer Gen8 是 HP 服务器里较新的一个系列, 其所配备的磁盘阵列卡 &amp;mdash; Smart Array Controller B120i, 也是比较新的一种阵列卡, 目前 HP 仅提供了 RHEL, OpenSUSE, Microsoft 的驱动程序.
我们就是要在 MicroServer Gen8 上安装 RHEL6.
MicroServer Gen8 的主板上的 ROM 上搭在了一个小型的配置系统, 叫做 Intelligence Provisioning, 在这里你可以对磁盘阵列进行分区(正如 hardware raid 都会带有一个控制系统来管理自己的说法一样), 还可以配置你要安装的操作系统(不过在通过这个配置你可以安装的系统有限, 仅限于 HP 提供了阵列卡驱动的那些系统), 还带了一些系统健康状态监控的功能.
对于上述的几个可以在 Intelligence Provisoning 中配置的操作系统, MicroServer Gen8 似乎都提供了他们的安装程序, 这点比较方便, 因为在 Intelligence Provisioning 中配置好我们想安装的操作系统之后, 重启机器就回进入这个操作系统的安装界面, 然后你只需要提供操作系统的镜像就可以继续你的安装. 但是 Gen8 预置的 RHEL 操作系统安装程序却是有一个严重的不如人意的地方, 稍候我会说明这一点.
众所周知, 安装软件时, 一般来说这个软件会提供一个安装程序, 我记得 windows 下以前最火的制作安装程序的软件叫 InstallShield 不知现在还是不是最火的, 使用这个软件就可以制作出那种傻瓜化的一路下一步的软件安装程序, 而 linux 下的安装程序, 应该就得算各种包管理系统或者是.</description></item></channel></rss>
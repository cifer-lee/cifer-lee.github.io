<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Cifer"><title>对解释器与 JIT 的一点思考 ｜ 编程笔记</title><meta name=description content="我一直知道解释器与编译器的区别. 编译器是事先将代码编译成机器码, 然后直接送进内存让 cpu 执行, 解释器则是解释执行代码, 可能会将代码先转换成一种中间码, 但我一直有一个误区就是解释器在解释执行的时候会把源代码"><link rel="shortcut icon" href=https://cifer97.github.io/images/favicon.ico><link rel=stylesheet type=text/css media=screen href=https://cifer97.github.iocss/normalize.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css><link rel=stylesheet type=text/css media=screen href=https://cifer97.github.io/css/zozo.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css><link rel=stylesheet type=text/css media=screen href=https://cifer97.github.io/css/highlight.css></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul></ul></div><div class=menu_icon><a id=menu_icon><i class=ri-menu-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=https://cifer97.github.io><span>编程笔记</span></a></h1></div><div class=description><p class=sub_title></p><div class=my_socials><a href=https://cifer97.github.io/index.xml type=application/rss+xml title=rss target=_blank><i class=ri-rss-fill></i></a></div></div></div></div><div class=content><div class=post_page><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><h2><a href=/posts/jit/>对解释器与 JIT 的一点思考</a></h2><span class=date>2018.12.10</span></div><div class="post_content markdown"><p>我一直知道解释器与编译器的区别. 编译器是事先将代码编译成机器码, 然后直接送进内存让 cpu 执行, 解释器则是解释执行代码, 可能会将代码先转换成一种中间码, 但我一直有一个误区就是解释器在解释执行的时候会把源代码或者中间码转成机器码, 也直接交由 cpu 执行, 然而我错了. 解释器是不会把源代码或者中间码转换成机器码的, 源代码或者中间码是直接在解释器内部的虚拟机上执行的.</p><p>当我认识到这一点之后, 我首先想到的虚拟机怎么实现的基本操作? 比如不借助 cpu 中的 ALU (加法器), 虚拟机怎么实现加法操作? 比如 2 + 3 这个表达式, 在词法分析后得到 &ldquo;2&rdquo; &ldquo;+&rdquo; &ldquo;3&rdquo; 三个 token, 虚拟机可以知道这是加法, 但是它怎么知道 &ldquo;2&rdquo; 和 &ldquo;3&rdquo; 分别代表多少? 2 + 3 它要怎么计算? 这是虚拟机无法模拟的. 略加思考, 我明白了, 试想一下, 虚拟机是什么语言写的? 虚拟机又是运行在哪里?</p><p>对的, 虚拟机本质上还是一坨直接运行于 cpu 之上的机器码, 当它拿到 &ldquo;2&rdquo; &ldquo;+&rdquo; &ldquo;3&rdquo; 的时候, 就直接讲这道题交给 cpu 的 ALU 去完成了, 然后取得结果作为它所解释的程序的运行结果.</p><p>那么 JIT (Just in Time) 是什么呢? JIT 实际上还是将源代码编译成机器码交由 cpu 执行. 可是从上述过程中可以看到, 虚拟机自己已经能够解释执行源程序了, 为什么还要将源代码编译成机器码交给 cpu 执行呢? 这是因为虚拟机毕竟也是跑在 cpu 上的程序, 一段相同的逻辑由虚拟机解释执行毕竟没有直接交给 cpu 执行更快.</p><p>但是编译也是耗时的啊, 开 JIT 虽然能把源代码编译成机器码, 但是一遍解释一遍编译, 那不会将机器码执行快速的优势抵消吗? 这就是一个权衡的问题了, 程序设计中有一个定律叫做 90% 的工作实际上是由 10% 的代码完成的. 所以 JIT 尽可能做到的就是找出这 10% 的代码仅将它们给编译了, 这样就 ok 了.</p></div><div class=post_footer><div class=meta><div class=info><span class="field tags"><i class=ri-stack-line></i>
<a href=https://cifer97.github.io/tags/jit/>JIT</a></span></div></div></div></div><div class=doc_comments></div></div></div></div><a id=back_to_top href=# class=back_to_top><i class=ri-arrow-up-s-line></i></a><footer class=footer><div class=powered_by><a href=https://varkai.com>Designed by VarKai,</a>
<a href=http://www.gohugo.io/>Proudly published with Hugo</a></div><div class=footer_slogan><span></span></div></footer><script src=https://cifer97.github.io/js/jquery-3.5.1.min.js></script><link href=https://cifer97.github.io/css/fancybox.min.css rel=stylesheet><script src=https://cifer97.github.io/js/fancybox.min.js></script><script src=https://cifer97.github.io/js/zozo.js></script></body></html>
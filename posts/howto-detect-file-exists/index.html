<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Linux C 中如何正确的判断一个文件/目录文件是否存在 -</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-48551763-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class="logo logo--mixed"><a class=logo__link href=/ title=狂想曲 rel=home><div class="logo__item logo__imagebox"><img class=logo__img src=/logo.png></div><div class="logo__item logo__text"><div class=logo__title>狂想曲</div><div class=logo__tagline>勇敢的灵魂追寻本我</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Linux C 中如何正确的判断一个文件/目录文件是否存在</h1></header><div class="content post__content clearfix"><blockquote><p>source: <a href=http://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c-cross-platform>http://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c-cross-platform</a></p></blockquote><p>其实不光是在 Linux 下编程, 在其他平台下我们都会有这样的需求: 我们要为应用程序创建自己的数据或者日志目录, 应用程序在每次启动时会检查文件系统中是否已经有了自己的目录, 没有的话就创建它, 有了的话就跳过这一步. 那么如何去判断文件系统中是否已经存在了要创建的目录呢?</p><p>Linux 或者 GNU C 都没有提供一个像 file_exists() 这样直观的系统调用给我们, 所以我们得通过其它的调用来达成这个目标.</p><p>实际上当我第一次要解决这个问题时, 我先 google 了一下, 这个问题在 stackoverflow 上有人问过而且非常受欢迎, 很多人对这个问题又点赞又收藏的, 自然, 这个问题也收到了不少好的答案, 这篇文章算是对这些好答案的总结和延伸.</p><p>我们先来看一个大家都应该知道的方式, 第一种方式:</p><h1 id=fopen>fopen()</h1><p>fopen() 方法是流阶级的方法, 这个方法接收用户提供的文件名, 以及访问方式, 然后尝试着打开文件, 打开成功则返回 handle, 失败则返回 NULL. 因此有人提出了使用这个方法来判断指定的文件是否存在的方案:</p><pre><code>#include &lt;stdio.h&gt;

...

FILE *fp = NULL;
fp = fopen(&quot;/tmp/test/somefile&quot;, &quot;r&quot;);

if(fp) {
  // exists
} else {
  // not exists
}

fclose(fp);
</code></pre><p>这也是 stackoverflow 上唯一一个得负分的答案, 这个方案的问题在于它没有考虑到文件权限的问题, 而 fopen() 这个函数又是如此的简单 &mdash; 不管因为什么原因打开文件失败了, 它只是返回 NULL 给你, 不会提供更多的错误信息.</p><p>如果文件存在, 而只是你没有对这个文件的读权限, 那么你同样会得到 NULL 返回值, 而你又不能获得其它导致失败的原因, 于是你想当然的认为这个文件不存在, 于是错误就发生了. 下面的两种情况都能够导致你打开失败:</p><ol><li>你对 test 目录没有 x 权限</li><li>你对 somefile 没有 r 权限</li></ol><p>这两种情况下, 显然文件是存在的, 但是我们却得到了 NULL 返回值.</p><h1 id=open>open()</h1><p>一个改进的放案是使用 open() 系统调用, 这是处于 fopen() 底层的调用, 它提供了丰富的出错信息, 以便于你能够检查出错的原因. 这个方案如下:</p><pre><code>#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;

...

fd = open(pathname, O_RDONLY);
if(fd &lt; 0) {
    switch (errno) {
        case EACCES:  // you don't have permission
        break;
        case ENOENT:  // the file doesn't exists
        break;
        default:
        break;
    }
} else {
    // use the file
}

close(fd);
</code></pre><p>使用 open() 调用能够帮你完成很多其它的额外的功能, 比如说在文件不存在的时候创建它, 等等.</p><p>看起来 open() 的解决方案已经足够了, 但是, 说到底 open() 是需要打开一个文件的, 可能你只是想检查文件是否存在, 而并不想读取它的内容, 这样打开操作就带来了不必要的工作. 如果仅仅是想检查文件是否存在, 或者是否对文件有读, 写, 执行权限的话, 我们还有另一种更好地选择:</p><h1 id=access>access()</h1><p>access() 调用以一种更明朗的方式专门检查文件是否存在, 文件是否可读, 可写, 可执行. 不过需要注意的是, access() 在检查文件是否存在以及程序对文件是否具有读写执行权限时, 使用的是程序的实际用户 ID, 而不是有效用户 ID. 实际上这个特点对于 &ldquo;setuid 化&rdquo; 的程序是很有用的, 因为 &ldquo;setuid 化&rdquo; 的程序可能常常会检查实际用户对某一文件是否具有响应的权限.</p><p>使用 access() 来检查文件是否存在的代码如下:</p><pre><code>if( access( fname, F_OK ) != -1 ) {
    // file exists
} else {
    switch(errno) {
        case EACCES:
            break;
        case ENOENT:
            break;
    }
}
</code></pre><p>access() 在失败时也会通过 errno 提供错误信息, 当你对要检查的文件的父目录没有 x 权限时, 会产生 EACCES; 当要访问的文件不存在时, 会产生 ENOENT.</p><h1 id=stat>stat()</h1><p>以上几种方法, 都只是根据我们指定的文件名来判断这个文件是否存在, 而不管它是一般文件还是目录文件, 如果我们不仅要确认一个文件存在, 还要确认它是目录文件, 那上面几种方法就不能满足了, 这时候我们可以用 stat() 调用:</p><pre><code>struct stat st_stat = {0};
int ret = stat(DBDIR, &amp;st_stat);
///
// 如果 stat 调用失败不是由于文件不存在导致的, 那么直接返回
//
if(ret &amp;&amp; errno != ENOENT) {
  fprintf(stderr, &quot;Check directory error: %s\n&quot;, strerror(errno));
  return 1;
}

///
// 如果 stat() 调用失败是由于目录不存在, 就创建目录
// 如果 stat() 调用没有失败, 但是已经存在的那个文件不是目录文件, 也创建它
//
if((ret &amp;&amp; errno == ENOENT) || (! ret &amp;&amp; ! S_ISDIR(st_stat.st_mode))) {
  ///
  // 创建目录并赋予其 rwxr-xr-x 权限
  //
  if(mkdir(DBDIR, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)) {
    fprintf(stderr, &quot;Crate directory error: %s\n&quot;, strerror(errno));

    return 1;
  }
}
</code></pre><h1 id=note>Note</h1><p>以上四个函数调用都会收到一个共同的限制: 如果要检查的文件/目录文件的父目录没有 x 权限, 那么都会产生 EACCES 错误或者返回 NULL(fopen).</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/c/ rel=tag>C</a></li><li class=tags__item><a class="tags__link btn" href=/tags/linux/ rel=tag>linux</a></li></ul></div></footer></article></main><section class=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//justforfree.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 .
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>
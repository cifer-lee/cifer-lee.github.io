<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>以太坊智能合约快速上手 -</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="以太坊 智能合约 solidity ethereum smart contracts"><meta property="og:title" content="以太坊智能合约快速上手"><meta property="og:description" content="以太坊 智能合约 solidity ethereum smart contracts"><meta property="og:type" content="article"><meta property="og:url" content="/posts/ethereum-smart-contract-quickstart/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-25T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-25T00:00:00+00:00"><meta itemprop=name content="以太坊智能合约快速上手"><meta itemprop=description content="以太坊 智能合约 solidity ethereum smart contracts"><meta itemprop=datePublished content="2021-05-25T00:00:00+00:00"><meta itemprop=dateModified content="2021-05-25T00:00:00+00:00"><meta itemprop=wordCount content="510"><meta itemprop=keywords content="ethereum,smart contracts,solidity,"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-48551763-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class="logo logo--mixed"><a class=logo__link href=/ title=狂想曲 rel=home><div class="logo__item logo__imagebox"><img class=logo__img src=/logo.png></div><div class="logo__item logo__text"><div class=logo__title>狂想曲</div><div class=logo__tagline>勇敢的灵魂追寻本我</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/reading/><span class=menu__text>书单</span></a></li><li class=menu__item><a class=menu__link href=/eight-part-essay/><span class=menu__text>技能树</span></a></li><li class=menu__item><a class=menu__link href=/investingrule/><span class=menu__text>投资理念</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>以太坊智能合约快速上手</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2021-05-25T00:00:00Z>2021-05-25</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/blockchain/ rel=category>Blockchain</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#开发环境搭建>开发环境搭建</a></li><li><a href=#智能合约撰写和编译>智能合约撰写和编译</a></li><li><a href=#合约的部署>合约的部署</a></li><li><a href=#合约的调用>合约的调用</a></li></ul></nav></div></div><div class="content post__content clearfix"><p>这两天学习以太坊合约开发, 不得不说以太坊社区是真 &ldquo;繁荣&rdquo;, 网上的教程多得数不胜数, 为什么繁荣加引号呢, 因为从这些教程的质量来看就知道, 以太坊社区的繁荣是各自为营, 社区里各式各样的团队各怀鬼胎的搞以太坊的生态建设, 而实际上根本目的都是为了推销自己的 dapp, 试图扩大自己在生态圈里的虚名，做以太坊社区 V 神之下的老二. V 神显然也不想做领袖角色, 社区就让他自由发展吧!</p><p>可是官方文档你好歹整好点, 我在官方想找个智能合约的 quickstart 都找不到, 官方文档说两句就丢你给个 remix 或者 truffle 等工具链接让你用那些工具写智能合约. 这不是我想要的, 我想学习的是不借助任何那些花里胡哨的 IDE 怎么把合约部署到主链上, 官方文档却不教你这一点, 没有这个信息, 即使有可能也是某个开发者的个人博客上有介绍(可能也是自己研究之后做个笔记), 而那些花里胡哨的工具的文档只会介绍自己的工具怎么样, 更不会跟你说底层原理.</p><p>不得已, 我只能多花了些时间把智能合约的开发部署捋了一遍. 下面我会摈弃虚华的外表, 让你能以最小的学习成本 + 最快的速度完成一个智能合约并发布.</p><h2 id=开发环境搭建>开发环境搭建</h2><p>环境方面我们需要:</p><ol><li>一个趁手的编辑器, 我选 vim 你随意</li><li>智能合约的编译器, 我们选择 <a href=https://docs.soliditylang.org/en/v0.8.4/installing-solidity.html#npm-node-js>solcjs</a></li><li>以太坊节点, 我们选择 geth</li><li>需要搭建一个测试或者私有网络, 我们选择 rinkeby 测试网络</li></ol><p>关于开发环境方面上述 4 点是我摸索出来成本最低最省事而又最接近在主网部署合约的配置, 诸位如果是第一次接触以太坊智能合约开发大可放心按我的方式来.</p><p>反观以太坊的官方文档, 看看它是怎么叫我们搭本地开发环境的:</p><p><a href=https://ethereum.org/en/developers/local-environment/>https://ethereum.org/en/developers/local-environment/</a>
<img src=local-dev-env.png alt></p><p>看到了吗, 直接甩给你一堆框架, 谁知道用哪个好, 官方就不能tm多写点自己写个教程吗.
算了, 闲槽少吐, 我们直接开始我们自己的流程.</p><p>1, 2 两步应该不用说了, 第 2 步我已经给出了 solcjs 的下载链接, solcjs 直接从 solc 编译器的 C++ 源代码用 Emscripten 生成的.</p><p>第 3 步 geth 节点是以太坊的官方 golang 实现, 当然是要用它.</p><p>第 4 步之所以我建议用 rinkeby 测试网络是因为第一私有网络搭建和维护相对麻烦, 要自己设计 genesis 状态, 自己在机器上起一到两个节点, 最关键的是市面上就没有完善的针对本地私有网络的区块浏览器, 这可会给调试带来很大的麻烦, 我用这种方式实践的时候创建了智能合约我都不知道进了哪个区块, 只能用得到的智能合约的地址先查出交易的哈希, 再用交易的哈希查处区块高度, 这些都是在 geth console 里敲命令完成的, 过程十分 annoying.</p><p>所以我们要选择测试网络, 那么问题又来了, 以太坊那么多测试网络, 为什么要选 rinkeby? 这是因为 rinkeby 网络用的是 PoA 共识而不是 PoW, 这样当你需要测试本地 geth 节点挖矿的话, 你的电脑风扇就不会因为 CPU 算哈希而狂转了.</p><p>另外, 当你不需要测试本地挖矿的话, geth 可以以 light 模式启动, 此模式下 geth 会变成一个轻钱包, 启动之后不需要看着那无休止的从 peers 下载历史区块数据的过程.</p><p>题外话, 关于 geth 的启动模式, 官方写文档的兄弟写了两句之后发现自己也不知道 light 是什么jb模式, 于是他可能 google 了一下, 找到了 stackexchange 上的这个回答:</p><p><a href=https://ethereum.stackexchange.com/questions/11297/what-is-geths-light-sync-and-why-is-it-so-fast>https://ethereum.stackexchange.com/questions/11297/what-is-geths-light-sync-and-why-is-it-so-fast</a></p><p>遂直接在<a href=https://ethereum.org/en/developers/tutorials/run-light-node-geth/>官方文档</a>上链接了这个回答:</p><p><img src=answer.png alt></p><p>对于这位兄弟我只想说你真他娘的是个小机灵鬼.</p><h2 id=智能合约撰写和编译>智能合约撰写和编译</h2><p>直接用这个最简单的合约.</p><pre><code>// SPDX-License-Identifier: GPL-3.0
pragma solidity &gt;=0.4.16 &lt;0.9.0;

contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }   

    function get() public view returns (uint) {
        return storedData;
    }   
}
</code></pre><p>然后用 solcjs 编译, 我们需要两个编译产物, 分别使用 <code>solcjs --abi</code> 和 <code>solcjs --bin</code> 命令编译两次源代码, 得到的一是智能合约的 ABI, 一是智能合约的实际字节码.
ABI 的内容, 如我们所愿, 长这样:</p><pre><code>[
  {
    &quot;inputs&quot;:[],
    &quot;name&quot;:&quot;get&quot;,
    &quot;outputs&quot;:[
      {
        &quot;internalType&quot;:&quot;uint256&quot;,
        &quot;name&quot;:&quot;&quot;,
        &quot;type&quot;:&quot;uint256&quot;
      }
    ],
    &quot;stateMutability&quot;:&quot;view&quot;,
    &quot;type&quot;:&quot;function&quot;
  },
  {
    &quot;inputs&quot;:[
      {
        &quot;internalType&quot;:&quot;uint256&quot;,
        &quot;name&quot;:&quot;x&quot;,
        &quot;type&quot;:&quot;uint256&quot;
      }
    ],
    &quot;name&quot;:&quot;set&quot;,
    &quot;outputs&quot;:[],
    &quot;stateMutability&quot;:&quot;nonpayable&quot;,
    &quot;type&quot;:&quot;function&quot;
  }
]
</code></pre><p>字节码就看不懂了:</p><pre><code>60806040523480156100115760006000fd5b50610017565b61016b806100266000396000f3fe60806040523480156100115760006000fd5b506004361061003b5760003560e01c806360fe47b1146100415780636d4ce63c1461005d5761003b565b60006000fd5b61005b600480360381019061005691906100b7565b61007b565b005b61006561008b565b60405161007291906100f2565b60405180910390f35b8060006000508190909055505b50565b6000600060005054905061009a565b9056610134565b6000813590506100b081610119565b5b92915050565b6000602082840312156100ca5760006000fd5b60006100d8848285016100a1565b9150505b92915050565b6100eb8161010e565b825250505b565b600060208201905061010760008301846100e2565b5b92915050565b60008190505b919050565b6101228161010e565b811415156101305760006000fd5b505b565bfea26469706673582212208a4ba997696b94e2c3116f2250c36954c3250d29aa10ecf4aa485a568623cc7764736f6c63430008040033
</code></pre><h2 id=合约的部署>合约的部署</h2><p>合约的部署实际上也是一个交易, 既然是交易就要有人为此支付 Gas, 所以首先我们得有一个有 ETH 的账户, ETH 这点不用担心, rinkeby 测试网络已经帮我们考虑到了. 创建好账户后到<a href=https://www.rinkeby.io/#faucet>这里</a>管 rinkeby 借点钱就行了</p><pre><code>$ geth --rinkeby account new
</code></pre><p>有了钱以后, 具体怎么发送这个交易呢? 手动构造交易的每个字段当然是很麻烦的, geth console 里提供了个 Contract 对象可以帮我们构造创建合约的交易并广播出去. Contract 对象由 <code>eth.contract(abi)</code> 方法创建, 其参数 <code>abi</code> 是个 JSON Object, 也就是上面我们编译出来的 ABI.</p><pre><code>&gt; var simpleStorage = eth.contract([{&quot;inputs&quot;:[],&quot;name&quot;:&quot;get&quot;,&quot;outputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;x&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;set&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;}])
</code></pre><p>得到了 Contract 对象后, console 里输入对象名, 可以看到 Contract 对象有如下的属性:</p><pre><code>&gt; simpleStorage
{
  abi: [{
      inputs: [],
      name: &quot;get&quot;,
      outputs: [{...}],
      stateMutability: &quot;view&quot;,
      type: &quot;function&quot;
  }, {
      inputs: [{...}],
      name: &quot;set&quot;,
      outputs: [],
      stateMutability: &quot;nonpayable&quot;,
      type: &quot;function&quot;
  }],
  at: function(address, callback),
  getData: function(),
  new: function()
}
</code></pre><p><code>abi</code> 就是创建 Contract 对象时的输入, 给我们原样又展示出来了, <code>new</code> 方法就是用来产生创建实现了此 ABI 的智能合约的交易并广播出去的, <code>at</code> 方法则是在合约创建成功之后, 根据合约地址创建一个能够操作此合约的抓手(或者叫做, handle, 句柄或实例), 是为了方便在 geth 中能够直接调用智能合约而存在的.</p><p>那么接下来就让我们调用 <code>new()</code> 方法来创建这个合约, 顺便把 <code>new()</code> 方法的参数也提供了:</p><pre><code>&gt; var bytecode= &quot;0x60806040523480156100115760006000fd5b50610017565b61016b806100266000396000f3fe60806040523480156100115760006000fd5b506004361061003b5760003560e01c806360fe47b1146100415780636d4ce63c1461005d5761003b565b60006000fd5b61005b600480360381019061005691906100b7565b61007b565b005b61006561008b565b60405161007291906100f2565b60405180910390f35b8060006000508190909055505b50565b6000600060005054905061009a565b9056610134565b6000813590506100b081610119565b5b92915050565b6000602082840312156100ca5760006000fd5b60006100d8848285016100a1565b9150505b92915050565b6100eb8161010e565b825250505b565b600060208201905061010760008301846100e2565b5b92915050565b60008190505b919050565b6101228161010e565b811415156101305760006000fd5b505b565bfea26469706673582212208a4ba997696b94e2c3116f2250c36954c3250d29aa10ecf4aa485a568623cc7764736f6c63430008040033&quot;
&gt; var deploy = {from: &quot;0xc97c9e1f5f842e37544e7790cdda32fef0f8b688&quot;, data:bytecode, gas: 2000000}
&gt; var handle = simpleStorage.new(deploy)
</code></pre><p>这里 bytecode 会随广播进入到矿工节点的区块中进而在所有其他节点中存下来, 这就是将来 EVM 要执行的代码.</p><p>上面 &ldquo;0xc97c9e1f5f842e37544e7790cdda32fef0f8b688&rdquo; 是我在 rinkeby 网络的地址, 并且已经通过 rinkeby faucet 要到钱了.</p><p>最后一步 <code>new()</code> 会广播交易, 交易成功之后我们的 geth 节点会收到成功的通知, 并将结果反映到 handle 上, 我们立即看一下 handle 的内容:</p><pre><code>&gt; handle
{
  abi: [{
      inputs: [],
      name: &quot;get&quot;,
      outputs: [{...}],
      stateMutability: &quot;view&quot;,
      type: &quot;function&quot;
  }, {
      inputs: [{...}],
      name: &quot;set&quot;,
      outputs: [],
      stateMutability: &quot;nonpayable&quot;,
      type: &quot;function&quot;
  }],
  address: undefined,
  transactionHash: &quot;0x104fb78f40a7265f08cc2566f75707b5140003b264baba06a449497cac81992b&quot;
}
</code></pre><p>可以看到 <code>transactionHash</code> 的值, 这个 hash 是广播的时候生成的, 所以自然是立即就能得到. 但是 address 还没有值, 这是因为我们立即交易还没被确认, 稍等 15s, rinkeby 上的矿工们会确认我们的交易, 这时在看:</p><pre><code>&gt; handle
{
  abi: [{
      inputs: [],
      name: &quot;get&quot;,
      outputs: [{...}],
      stateMutability: &quot;view&quot;,
      type: &quot;function&quot;
  }, {
      inputs: [{...}],
      name: &quot;set&quot;,
      outputs: [],
      stateMutability: &quot;nonpayable&quot;,
      type: &quot;function&quot;
  }],
  address: &quot;0xc6c5500ab9dc7fcc7efb6c95033604a7f00a3042&quot;,
  transactionHash: &quot;0x104fb78f40a7265f08cc2566f75707b5140003b264baba06a449497cac81992b&quot;,
  allEvents: function(),
  get: function(),
  set: function()
}
</code></pre><p>Bingo! 此处无须多言了吧.</p><p>etherscan.io 上有针对 rinkeby 的区块浏览器, 可以看到这次交易的详情: <a href=https://rinkeby.etherscan.io/tx/0x104fb78f40a7265f08cc2566f75707b5140003b264baba06a449497cac81992b>https://rinkeby.etherscan.io/tx/0x104fb78f40a7265f08cc2566f75707b5140003b264baba06a449497cac81992b</a></p><p>这要是本地私有网络, 就没有这么方便的浏览器可用了, 这是我花了一个多小时得出的经验.</p><h2 id=合约的调用>合约的调用</h2><p>我们可以直接用刚刚的 handle 调用 get/set 方法. 如果你是第二天重新进入的 geth, 则需要先构造出 Contract 对象, 然后再用 at 方法获得 handle.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/ethereum/ rel=tag>ethereum</a></li><li class=tags__item><a class="tags__link btn" href=/tags/smart-contracts/ rel=tag>smart contracts</a></li><li class=tags__item><a class="tags__link btn" href=/tags/solidity/ rel=tag>solidity</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><div class=authorbox__header><span class=authorbox__name>About Cifer</span></div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/posts/anaerobic-aerobic-exercise/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>有氧运动和无氧运动的区别</p></a></div></nav><section class=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//justforfree.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 Cifer.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script></body></html>
<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Rust 里的单例模式</title><link rel=stylesheet href=/css/style.css></head><body><header><a href=https://cifer97.github.io>编程笔记</a></header><main><article><h1>Rust 里的单例模式</h1><time>2020.07.11</time><div><p>Rust 要想搞个单例模式还真是曲折.</p><p>单例模式说到底就是全局变量, 在别的语言很容易实现, 但是在 rust 里则诸多不便, 因为 rust 这门语言从设计上就是要避免使用全局变量的. 实际上 Rust 里就没有全局变量的概念, 只有生命周期的概念, 全局变量某种意义上也就是具有整个运行时周期的静态变量, 如果我们真的要定义全局变量, 那就用 static 关键字. 后面我们姑且不论全局变量和静态变量的区别, 统一用静态变量的说法.</p><p>Rust 的 static 关键字和 C/C++ 语言一样, 代表变量的生命周期是整个运行时, 但是相比 C/C++ rust 的 static 有一个限制: 必须使用编译时期能够确定的值初始化. 刚看到着点有点想吐槽, 这不就跟 const 常量有点像了么, 不过一想这应该也是 rust 为了安全考虑, 防止运行时有多处地方想要初始化这个静态变量. 但是给我们造成的麻烦可就不小了, 具体麻烦程度取决于我们需不需随后在运行时修改这静态变量的值, 需要分别讨论.</p><p>如果我们运气好不需要运行时修改静态变量, 意味着变量声明不用加 mut, 那就很好, 虽然这种情况其实直接用 const 就行了&mldr; 但总之看起来至此需求满足了, 讨论可以结束? 很遗憾并没有.</p><p>往往我们用单例模式都是要和系统资源打交道的, 比如网络连接, 文件描述符等, 这些系统资源当然本身是不支持同步访问的, 需要上层有一种机制保证对他们的访问是同步的. 对于 unmutable 的静态变量, rust 会编译时检查这个变量类型是否本身支持同步访问, 支持则已, 不支持则会报错. 不愧是 rust, 多么的严谨哦~ 那 rust 是怎么检查的呢? 首先 Rust 提供了一个名为 Sync 的特性 (Trait, 可以认为是 OOP 里的接口), rust 的检查就是看类型有没有实现这个 Sync 特性, 单纯说是检查其实不准确, 实际上是边检查边补缺, rust 在编译阶段足够智能的为一些类型自动实现 Sync 特性, 比如基础类型, 基础类型的 Vec, 甚至自定义的简单的结构体类型, 对于 rust 不能自动实现 Sync 的类型, 才会去检查这个类型有没有显式的实现 Sync 特性, 有则已, 没有则报错.</p><p>不难想象, 对于封装了系统资源的外部的类库, rust 一般是不能自动为其实现 Sync 的, 这就需要三方库自己去实现, 如果没有实现, 就会报错. 当我们引用了某个提供 redis 访问功能的第三方库, 并想在这种情况下, 采用单例模式时, 要关注一下这个第三方库有没有实现 Sync. 那如果第三方库就是没有实现 Sync 该怎么办呢? 其实也不难, 就是我们自己用 std::Sync::Mutex 模板类包裹一下第三方库的实例.</p><p>至此才算是在 &ldquo;不需要运行时修改静态变量&rdquo; 这个情况下, 成功实现了单例.</p><p>那么如果我们需要再运行时修改这个静态变量呢?</p><p>这其实才是更常见的情况, 首先这种情况我们必须得将静态变量声明为 mut 了, 一旦声明为 mut, 编译器就不会检查这个变量类型是否有实现 Sync 特性了 咦？事情好像变得简单的？并不是，编译器只是换了一种方式，并且是更严格的方式来检查。 编译器会直接质问你 &ldquo;你竟然要在代码里修改静态变量?!&rdquo; 而你则可能会想 &ldquo;WTF? 修改静态变量怎么了? 既然名字叫变量还不准我改了? 我在别的语言想怎么改怎么改&rdquo;. 是的, 在 rust 里就是不能改, 因为静态变量的修改本来就会引起竞争问题, 在别的语言也不例外, 只不过别的语言是靠我们手动加锁避免这个问题, 当然在别的语言里就算我们没加锁编译器可能也不会检查和报错, 所以一旦出问题就是运行时问题了. 而 rust 是靠编译器在编译时期检查这个问题, 一旦发现代码里有修改全局变量引起数据竞争的可能性, 就会直接拦下.</p><p>在 rust 里你当然可以在每处访问修改静态变量的地方加锁, 但 rust 编译器还没有强到能够分析代码逻辑的境界, 所以还需要一点辅助手段. 这就要使用 Rust 编译器提供的 (甩锅) 方法, 找到修改 static 变量的那行代码, 把它用 <code>unsafe</code> 块包裹起来就行了, 用了 unsafe 就是接受了 rust 甩锅, 从编译器视角看: &ldquo;unsafe 块里的修改是你硬要改的, 不是我让改的, 出问题你自己负责&rdquo;.</p><p>一定要注意的是, unsafe 仅仅是解决了编译器的报错, 是一种 &ldquo;蒙混过关&rdquo; 的解决方式, 对静态变量并发访问的风险还在, 实际上在 unsafe 块里我们多数情况要手动对 static 变量的访问加锁的. 但不管我们实际加没加锁，只要用 unsafe 包裹了，编译器就完全撒手不管了，它认为我们会自己保证同步性，自然也不会多此一举检查类型有没有实现 Sync 特性了。</p></div><div><ul id=tags><li><a href=/tags/rust>rust</a></li><li><a href=/tags/programming>programming</a></li></ul></div></article></main><footer><p>&copy; 2021 <a href=https://cifer97.github.io>编程笔记</a></p></footer></body></html>
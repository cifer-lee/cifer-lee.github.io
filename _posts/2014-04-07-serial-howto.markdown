---
layout: post
title: 彻底明白串行口
date: 2014-04-07 10:39
---

# 介绍

如今串行口在个人电脑上已经越来越少见了, 但是在嵌入式系统中仍然很常见, 比如路由器, POS 机设备等. 这篇文章也介绍了多串口卡(Multiport Serial Cards). 这篇文章写于串行口还是 PC 连接调制解调器(modem), 打印机等的主要手段的年代. 如果你不了解串行口, 想要弄明白它是怎么工作的, 或者你想找一份资料来帮助你学习串口编程, 那么本文就是你想要的.

这篇文章讲述的是比较原始的 "UART serial port", 而不是那些新型的串行设备: Uniersal Serial Bus(USB) 或者火线(Firewire, 如 1394). 比起 USB 或者火线, UART 串行口的速度要低很多, 但是相对你读取它的速度, 还是很快了. 

如果你想了解使用串行口的设备, 像是调制解调器(modem)[1], 文字终端(text-terminals), 红外设备(infrared devices) 等的相关资料, 可以查阅响应的 Modem-HOWTO, Text-Terminal-HOWTO, Infrared-HOWTO, 以及 Printing-HOWTO.

有关 getty[2] 的信息也转移到了其它相关的 HOWTOs, 因为现在兴起了太多的 getty 变体: mgetty 和 uugetty 适合 modem, agetty 适合文字终端.

这篇文章是针对运行在 PC 机上的 Linux 系统的(ISA and/or PCI 总线), 但是这篇文章也适合其它的架构.

## 什么是串行口(Serial Port)

我们这里通常所说的串口(不是较新的 USB 或者火线)是一种非常古老的 I/O 口(原文叫做 conventional serial port, 我们就叫做老串口吧). 1990 年的桌面 PC 一般会有两个串口, 2006 年的桌面 PC 只保留一个串口, 笔记本电脑很早就放弃了串口. Mac 电脑从 1998 年起就只使用 USB 口. 但是, 将一个老串口设备插在 USB 总线上用也是可能的.

每一个串行口都有一个对应的文件在 /dev 目录下. 比如 /dev/ttyS0, /dev/ttyS1. 在 USB 总线上的串口设备可能有不同的名字.

老串口有一个规范叫做 RS-232, 因此老串口也常常被称作 "RS-232 串口". 这种串口的连接头一般是 9 针或 25 针. 每一针产生的电流都遵循 RS-232 规范.

在 RS-232 规范里, 有一个针用来发送数据, 一个针用来接收数据, 一个针接地. 其它针也各有自己的用途.

UART 芯片能够完成几乎所有的这些功能, 如今 UART 芯片的功能一般被集成到其它芯片里去.

# 硬件是如何传输字节的

下面是关于这个问题的介绍, 更详细的内容可以参见后面的章节.

## 发送

发送就是指将字节从电脑的串口发送出去. 当电脑想要发送一个字节到串口(即是到外设)时, CPU 会将这一字节送到总线上(假设这个字节取自内存中)进而送到串口的 I/O 地址上. 串口得到了这个字节, 于是再将其通过针脚发送出去, 每次一个 bit.

下面我们详细的说一下上面的过程(但是仍然不完整). 串口绝大多数的工作都是被 UART 芯片完成的. 为了发送一个字节, 串行设备的驱动程序(在 CPU 上运行) 先将这个字节发送到串口的 I/O 地址. 然后这个字节进入串口里面的一个"一字节发送偏移寄存器"(1-byte transmit shift register), 在这个偏移寄存器中, 字节中的位被一个一个的提取出来然后发送到串行线上, 当最后一位被发送时, 偏移寄存器再读入下一个字节.

偏移寄存器再读入下一字节的时候, 可以直接向 CPU 要(发起 IRQ 请求), 但这是很低效的, CPU 要做其它事, 而且做的比串口快, 不能串口一缺数据, CPU 就中断来给串口提供数据, 这也是众所周知的 CPU 与外设速度不一的问题, 解决这个问题的方式就是引入串口缓冲区.

最早缓冲区的大小采用 1 字节, 后来是 16 字节, 再后来应该更大了.

每当串口缓冲区没有字节(或者快要没有)的时候, 串口会向 CPU 发出中断请求, CPU 会知道是谁发出的中断因为每一个串行设备都有一条专门的中断线(除非这个中断线是共享的). 于是 CPU 会运行这个串行设备的驱动程序, 驱动程序会检查设备为什么要发起中断, 如果检查到是设备想要数据的话, 那么就再往串口缓冲区防数据.

因此, 我们称串口是中断驱动(interrupt driven)的. 

## 接收

接收过程也是中断驱动(interrupt driven)的. 当有字节被从外部的设备接收时, 串口会向 CPU 请求一个中断, 告诉 CPU 来读取这些字节, 以便于串口可以继续接收下面的字节.

## 串口大缓冲区

我们前面说的是 1 字节, 16 字节的缓冲区, 当然其实也有大缓冲区, 像是 8k 的. 

这些缓冲区都是由驱动程序管理. 但是驱动程序的作用不光是管理这些缓冲区. 它还做一些过滤, 数据控制等工作. stty 程序可以用来调整串口的参数.

# 串行口基础

了解一下串行口的基础知识是不错的.

## 什么是串行口?

### 串行口的简介

UART 串行口设备.

I/O 设备是一种将数据输入或输出电脑的方式. 有很多类型的 I/O 设备, 比如老串行口, 并行口, 网络卡, USB, 火线等. 2007 年以前的电脑大多有一到两个老串行口, 每个串口有个 9 针或 25 针连接头在主机后面. 计算机程序可以将数据发送到发送引脚, 也能从接收引脚接收数据. 其它的引脚都与控制信号和接地有关.

串行口不仅仅是个连接头. 它还能够将并行数据转换成串行数据, 改变电流表征. 在计算机内部, 数据在总线上是以并行方式传输的. 通过串口发送出去时回转换成串行数据.

这就是 UART 芯片(或其他功能相同的芯片)要做的事.

### RS-232

老串口(不是 USB) 通常是 RS-232-C, EIA-232-D 或者 EIA-232-E. 这三个基本可以算是一个东西. RS-232 这种叫法已经越来越少, 逐渐被其它两种叫法取代.

## IO 地址与中断请求

因为主机需要和每一个串口通信, 它必须知道串口的存在以及其所在的位置(它的 I/O 地址), 它也必须知道串口会用哪一条中断线(IRQ number)来发起中断请求. 每一个串口设备也必须将其 I/O 地址与其 IRQ 号码存在它的非易失存储器中. PCI 总线可能有自己的中断系统, 不过 BIOS 会把 PCI 总线上的中断请求映射到一般的中断.

## 名字: ttyS0, ttyS1 等

串行口命名为 ttyS0, ttyS1 等. 每一个物理串口都在 /dev 下有一个特殊的文件. 可以输入 "ls /dev/ttyS\*" 来查看他们. 但是要注意的是, 有一个 /dev/ttyS3 文件并不代表存在一个物理的串行口与其对应.

哪一个文件对应哪一个物理串口是这样决定的. 串口驱动(软件)维护着一张表, 记录着哪一个 I/O 地址对应哪一个文件. 名字与 I/O 地址(以及 IRQ number)可以用 setserial 命令来查看以及设置. 这并不会将地址或者是 IRQ number 写入到物理设备中(物理设备的地址以及 IRQ number 是在插入设备的时候由 jumpers 或者 plug-and-play 软件设置). 因此哪一个物理串口对应哪个文件是由串口驱动和物理设备自身共同决定的.

## 中断

当串口缓冲区接收到指定数量的字节(你可以设定为 1, 2, 4, ... 字节), 串口会发起一个终端请求给 CPU, 让 CPU 读取这些字节. 但是, 这个中断请求也可能在缓冲区没有收够足够的字节时发起, 这发生在你同时指定了一个超时值的情况下. 

如果缓冲区的字节来的很慢(比如串口接的是键盘和鼠标), 那么可能每来一个字节就发起一次中断. 对于一些 UART 芯片, 规则是这样的: 在规定的时间内, 本来打算等待 4 字节到缓冲区, 但是到了时间时却只有 2 个字节在缓冲区, 那么串口会放弃等待另外两个字节, 而是直接发起中断让 CPU 来读取已有的 2 个字节. 当然, 如果缓冲区中一个字节也没有, 那么串口就不会发起中断.

每一个中断管理者(interrupt conductor, 在主机内部)都管理着一个 IRQ 号码, 串口必须知道它由哪个管理者管理(使用哪个 IRQ 号码). 比如说, ttyS0 一般是使用 IRQ 号码 4, 即 IRQ4. 更多串口的 IRQ 号码可以查阅 `man setserial`, 任何时候串口想要取得 CPU 的注意都会发起中断, 一定要不时的就发起中断, 因为串口缓冲区大小有限, 一旦满了, 而 CPU 又没有及时读取, 那么后面的字节就回将缓冲区中前面的字节覆盖.

# 译注

注[1]: 调制解调器是一种能将数字信号调制到模拟信号, 也能将模拟信号解调到数字信号的设备, 俗称"猫".

注[2]: getty 是一个运行 login 程序的程序. getty 一般运行在某一终端上, 而终端又是通过串行口连接到 PC.

<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程笔记</title><link>https://cifer97.github.io/</link><description>Recent content on 编程笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 02 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer97.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>聪明的投资者笔记</title><link>https://cifer97.github.io/posts/the-intelligent-investor-notes/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/the-intelligent-investor-notes/</guid><description>第 5 章 防御型投资者与普通股 首先格雷厄姆给出了防御性投资者投资普通股的 4 条准则 &amp;mdash; 都是很保守的准则.
然后格雷厄姆说明了不建议防御型投资者投资成长股.
最后推荐了一种特别适合防御性投资者的投资方式: 美元成本平均法. 也就是国内所谓的定投.
第 6 章 积极型投资者的证券组合策略: 被动方法 在这一章里格雷厄姆暂时没有给出积极型投资者的投资策略, 而是先指出了积极型投资者不应该做什么. 格雷厄姆不建议的事情如下:
不参与高等级优先股, 宁愿让给公司购买者 不参与低等级的债券和优先股, 除非有相当大的折价 不购买外国的政府债 对待新发行的证券 (包括, 股票, 可转债和优先股) 也要谨慎 具体原因到书里找答案, 无非就是风险不足以弥补收益.
但是, 这些观点是格雷厄姆所在的 20 世纪 70 年代的情形, 现在很多情形已经改变了. 贾森兹威格对这章的点评指出了多处不适用的点.
第 7 章 积极型投资者的证券组合策略: 主动的方法 不推荐的 不推荐择时
格雷厄姆首先排除了低买高卖的择时策略，理由是尽管看过去的走势图可以看出高低波动，但是这高低波动是完全没有规律的，普通人几乎不可能准确的抓住高低点。
不推荐成长股
接着格雷厄姆讨论到了成长股，首先注意对成长股的定义一定是企业在过去业绩表现很好，并且预计未来表现也会很好。仅仅有后面那条是不行的。
格雷厄姆列举了 1970 年之前的一些知名的成长股基金，发现他们的业绩还比不上标普和道琼斯指数。本书点评者贾森兹威格也用 2002 年的一些大型成长股基金的数据再次印证了这一点. 这说明连那些优秀的基金也不能准确的挑选出成长股，作为一个普通投资者这个可能性更小，所以格雷厄姆是不赞成成长股投资的。
那么为什么从成长股上难以取得超过市场的收益呢，因为当你发现成长股的时候, 市场也早就发现了并且给予了高估值，股价已经透支了未来的预期了。
不推荐钻破产重组或企业分拆的空子 这条不多说了, 有时候破产重组或者企业分拆不一定是利好.
推荐的 推荐购买被忽视的大公司股票
推荐购买廉价股票
这两条就不多说了
第 8 章 投资者与市场波动 首先提出投资者在波动的市场里有两种获利方法：择时和估价，股价也就是前面论述的分析公司财务壮况等信息并低价买入。</description></item><item><title>2020 年终总结</title><link>https://cifer97.github.io/posts/year-in-review-2020/</link><pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/year-in-review-2020/</guid><description>2020 年终总结 个人性格 始终还是优柔寡断的性格, 2021 年一定要改变这个性格.
工作 对管理有了一些思考, 一个管理者应该具备真正的资源把控能力, 而不应该单纯的就是派活给团队成员, 更不应该是 &amp;ldquo;拿着鞭子&amp;rdquo; 在团队成员后面催工的剥削者. 优秀成熟的管理者应当同时服务好上级和下属, 按时保质的完成上级的任务是当然的, 但是也不要牺牲下属的舒适度. 否则就可能会造成下属在巨大的压力下无法完成任务, 自己也无法向上级交付的尴尬. 个人技能 对 Tor 网络与代理的认识更深了 匿名主机, 匿名域名. 知道了如何在网络上匿名创办网站 加深了对 DNS 的了解 学习了 Rust 语言. 语言很不错, 就是条条框框有点多, 不适合我这种不需要编译器来保证内存安全的高手. 重新拾起了 python 并用 flask 做了个网站. 在一起体会了 &amp;ldquo;人生苦短, 我用 python&amp;rdquo; 的真谛, 因为同样地网站我先用 Rust 语言现学现做花了 10 倍多的时间 学习了 mongodb 数据库的使用, 以后我尽可能都不会再用 mysql 了 了解了如何通过创建 SSH tunnel 来翻墙 学习了怎么创建一个 HTTPS 服务 投资 今年开始学着买了基金和股票, 基金和股票的持仓部分取得了勉强胜过通胀的收益 开通了汇丰香港卡, 美股和港股也有所涉及.</description></item><item><title>Rust 里的单例模式</title><link>https://cifer97.github.io/posts/rust-singleton/</link><pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/rust-singleton/</guid><description>Rust 要想搞个单例模式还真是曲折.
单例模式说到底就是全局变量, 在别的语言很容易实现, 但是在 rust 里则诸多不便, 因为 rust 这门语言从设计上就是要避免使用全局变量的. 实际上 Rust 里就没有全局变量的概念, 只有生命周期的概念, 全局变量某种意义上也就是具有整个运行时周期的静态变量, 如果我们真的要定义全局变量, 那就用 static 关键字. 后面我们姑且不论全局变量和静态变量的区别, 统一用静态变量的说法.
Rust 的 static 关键字和 C/C++ 语言一样, 代表变量的生命周期是整个运行时, 但是相比 C/C++ rust 的 static 有一个限制: 必须使用编译时期能够确定的值初始化. 刚看到着点有点想吐槽, 这不就跟 const 常量有点像了么, 不过一想这应该也是 rust 为了安全考虑, 防止运行时有多处地方想要初始化这个静态变量. 但是给我们造成的麻烦可就不小了, 具体麻烦程度取决于我们需不需随后在运行时修改这静态变量的值, 需要分别讨论.
如果我们运气好不需要运行时修改静态变量, 意味着变量声明不用加 mut, 那就很好, 虽然这种情况其实直接用 const 就行了&amp;hellip; 但总之看起来至此需求满足了, 讨论可以结束? 很遗憾并没有.
往往我们用单例模式都是要和系统资源打交道的, 比如网络连接, 文件描述符等, 这些系统资源当然本身是不支持同步访问的, 需要上层有一种机制保证对他们的访问是同步的. 对于 unmutable 的静态变量, rust 会编译时检查这个变量类型是否本身支持同步访问, 支持则已, 不支持则会报错. 不愧是 rust, 多么的严谨哦~ 那 rust 是怎么检查的呢?</description></item><item><title>对协程的一点认识</title><link>https://cifer97.github.io/posts/coroutine/</link><pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/coroutine/</guid><description>协程的调度 我们知道线程是 CPU 的基本调度单元，线程调度靠的是时钟中断.
协程是执行于线程之内的更细粒度的执行单元，他的调度无法依赖时钟中断，而是要靠一个用户态的调度器，这个调度器可以是抢占式或非抢占式，抢占式调度器需要语言的运行时支持，据我所知只有 erlang 实现了协程的抢占式调度。大部分的协程实现都是非抢占式调度，非抢占式调度实际上是依靠协程之间相互让权 (yield) 来得到执行。
在非抢占式协程下，不存在协程同步问题。而在抢占式协程下则语言我们也考虑数据竞争，协程同步问题。
协程的好处 协程的一个典型应用是用在生产者 - 消费者问题中. 我们知道生产者 - 消费者问题也可以用多线程解决, 生产者线程和消费者线程共享一个上了锁的消息队列, 靠内核调度这两个线程执行来完成生产和消费过程, 然而这里有两个不足之处:
靠内核调度线程, 存在线程切换开销 消息队列加锁, 存在锁竞争和线程同步问题 内核调度线程的时机不确定, 如果在调度消费者时队列中没有消息, 消费者只能什么也不干就退出, 白白浪费了一次调度而如果用协程解决的话, 就不存在上述问题. 首先生产者和消费者协程位于统一线程里, 不存在线程切换的开销; 其次由于是单线程, 无需加锁, 也就不存在锁竞争问题; 最后由于协程之间的执行是靠主动让权 (yield), 我们可以在实现的时候仅当队列不空时才让权给消费者, 同理消费者仅当队列不满时才让权给生产者.
另外使用协程还有一个好处就是能够以看似同步的方式写异步的代码.
协程实现 要实现协程就需要自己在线程中维护第二层栈空间 (第一层是线程自己的栈空间), 因为线程的切换内核会为我们将当前上下文 (主要是各个寄存器的值) 保存在线程栈空间中, 现在由于线程需要自己调度协程, 所以线程需要为每个协程维护栈空间, 好在协程切换时保存协程的上下文.
这里需要线程能够获去到当前执行上下文, 很多操作系统内核会提供相应的系统调用, 实现方式其实也很简单就是写一段内嵌的汇编获取各个寄存器的值.
在 C/C++ 中, setjmp/longjmp 帮我们完成了这个任务. 关于其 setjmp/longjmp 的实现原理, 这里有篇 Google 排名第一的文章 讲的很清楚. C/C++ 中实现协程当然也可以不借助 setjmp/longjmp 而自己去实现上下文的获取和维护, Google 可以搜到不少.</description></item><item><title>2017 年终总结</title><link>https://cifer97.github.io/posts/year-in-review-2017/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/year-in-review-2017/</guid><description>学习 学会了使用 python 写简单的工具 从盛科辞职, 加入了滴滴 研究数字货币, 研究的很深. 投资了 HPB, BTS 和 STEEM 人生 结婚 在一沿海二线城市买了方, 买的时候已经不便宜了 浪费时间的瞎折腾 emacs, orgmode 为了使用 orgmode, 不得不学习折腾 emacs, 要是早点发现 onenote 就好了. 今后严格杜绝在这样的事情上浪费生命!</description></item><item><title>2016 年终总结</title><link>https://cifer97.github.io/posts/year-in-review-2016/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/year-in-review-2016/</guid><description>这是一篇拖了相当久的总结, 2016 年是我动荡不安的一年.
辞职 首先是 6 月份的辞职, 这是我在 Y 工作整整三年来的辞职. 那个时候我的脑中存在着不知从哪听到的一个观念: 三年是一个阶段, 在一家公司工作满三年了就可以跳槽了. 现在回想这个观念实在是没什么道理, 当然如果仅仅是我脑子里存在这个观念, 那还不足以让我辞职的. 不说笑, 驱使我辞职的根本原因还真的就是 &amp;ldquo;世界那么大, 我想去看看&amp;rdquo;. 于我而言, 这句话包含了两层含义, 一是我对工作现状的疲乏, 二是我对外面世界的憧憬.
当时在很长一段时间里, 我的工作是千篇一律的: 不断的为一些变来变去的, 无关痛痒的需求修改代码. 这些工作既繁琐, 又不存在技术壁垒, 久而久之我对这些工作产生了强烈的厌烦感, 我甚至觉得, 嵌入式领域我已经做到头了, 再继续做下去对我也不会有本质的提升, 关于这一点我后来更是坚信不疑.
另外, 从大学算起, 在青岛这个二线城市待了 7 年, 在嵌入式领域做了将近 3 年的我, 对外面更发达的城市, 对于外界的各个未知的领域都充满了渴望和幻想. 我想这才是导致我坚定的辞职的根本原因, 年轻的时候不出去, 什么时候出去呢?
总之辞职是一定的了, 但是在这次辞职的过程中, 暴露出了几个让我现在回想起来都遗憾万分的问题.
首先就是与上级的沟通太少, 这是我这三年里犯得非常严重的一个错误. 公司的同事, 尤其是上级, 在我们的职业生涯中是非常优质的资源, 如果我能利用好这些资源的话, 那么我的职业生涯必定会少走很多弯路, 然而整个在 Y 的三年我都没有重视这些资源. 在我离开 Y 的时候, 我与公司绝大部分同事甚至老板的关系都是很普通的, 这不应该是一个在公司待了三年的老员工的样子.
而且正是由于沟通太少, 我没有想到的是, 在我提辞职的那几天, 上级同时也在计划给我 promotion, 遗憾的是我先于上级的 promotion 提出了辞职, 后面的事情就比较尴尬了.</description></item><item><title>写在入职滴滴的前夕</title><link>https://cifer97.github.io/posts/acquired-by-didi/</link><pubDate>Mon, 20 Mar 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/acquired-by-didi/</guid><description>明天 (3.21) 就正式入职滴滴了, 这对我来说是非常值得开心的, 然而我这些天却越发的感觉到几丝迷茫.
现在想想, 从上了大学起, 我精神就一直处于一个懒散的状态, 整个大学里没有一点危机意识, 没有去思考我该做什么, 想要什么, 也没有去思考将来要成为什么样的人. 懒散到专业被调剂了也毫不在意的接受, 不去反抗不去挣取.
虽然大学的时候没有少看编程方面的书, 以后做程序员的决心也一直没有改变过, 但是我也仅仅只是心里一直告诉自己 &amp;ldquo;以后要成为出色的程序员&amp;rdquo; 罢了, 至于怎样才能成为, 成为了之后又怎样, 我没有过多思考过, 只是就一味的看书, 像无头苍蝇一样, 没有方向, 没有侧重. 现在想起来, 当是真的是浪费了太多的时间, 导致自己事倍功半.
整个大学时期, 我存在非常严重的几个问题:
认为专业被调到化学无所谓, 认为我靠自学计算机也能学得很好
事实上, 失去了计算机专业的学习环境, 教授环境, 没有前辈的引导, 我对于整个计算机生态体系缺乏系统的认识, 导致了我方向不清, 不能明确自己想要的是什么.
这导致的后果就是我在大学中, 几乎所有的计算机技术书籍都看过, 但是没有一项为我所熟练掌握, 我看过学过的内容过有计算机组成原理, 汇编, C/C++, MFC, Visual C++, Java, j2ee, php, mysql, oracle, flash 动画, html/javascript/css web 前端, android 开发, C#/.Net 开发等等. 但是看这些书时我是迷茫的没有方向的, 我甚至不知道为什么要看这些书, 看完之后能做什么.
闭门造车, 没有和其他人多多沟通</description></item><item><title>记一次 Indigo 与 Ryu 的连接建立问题</title><link>https://cifer97.github.io/posts/a-problem-ryu-indigo-conn-setup/</link><pubDate>Sun, 25 Dec 2016 16:03:13 +0000</pubDate><guid>https://cifer97.github.io/posts/a-problem-ryu-indigo-conn-setup/</guid><description>之前在研究 Indigo 和 Ryu 的衔接时碰到一个 OpenFlow 连接建立失败的问题, 特此记录下, 希望能够供别人参考.
在了解这个问题之前, 我们先回顾一下 OpenFlow 连接建立过程.
OpenFlow 协议的连接建立过程 根据 OpenFlow 协议标准的陈述我们能够知道, 交换机和控制器之间使用 TCP (或者 SSL) 传输协议, 交换机必须能够主动发起连接 (实际应用中, 连接一般都是都由交换机主动发起), 另外就是所有的 OpenFlow 消息, 都要用网络序 (大端序) 发送 (参见 OpenFlow Spec v1.3 以及 v1.4 的第 7 章)
TCP 连接的建立我们很熟悉了, 就是典型的三此握手过程. 在 TCP 连接建立以后, 交换机和控制器双方在 TCP 连接建立后需要立即发送给 OF_HELLO 消息给对方, 并且 OF_HELLO 必须是双发发送给对方的第一个消息, OF_HELLO 消息同时起到协商 OpenFlow 版本的功能.
当双方都收到了对方的 OF_HELLO 消息并且两边都共同支持一个最小版本, OpenFlow 连接就成功建立了, 接下来控制器就可以向交换机发送其它的消息, 比如一般第一次要发送的就是 OFPT_FEATURES_REQUEST 消息.
遇到的问题 在这部分工作中基于 Ryu 框架我写了个简单的 Ryu 小程序令它与 Indigo 通信, 但是发现似乎连接建立都不成功, 好在 indigo 项目的错误日志部分做的很好, 我打开了 verbose 级别的日志, 发现连接建立过程中 indigo 在收取 OF_HELLO 这个消息失败了, 结合代码发现是在读 socket 时发生了 EAGAIN (Resource temporary unvailable) 错误.</description></item><item><title>二叉树递归遍历的本质以及用迭代遍历精确模拟递归遍历</title><link>https://cifer97.github.io/posts/binary-tree-traversal/</link><pubDate>Sat, 22 Oct 2016 17:24:36 +0000</pubDate><guid>https://cifer97.github.io/posts/binary-tree-traversal/</guid><description>递归遍历是实现深度优先遍历的既直观又简单的方式, 二叉树递归遍历的本质其实就是在不断的压栈与出栈, 明白了这一道理之后就很容易借助栈结构来将递归遍历转换成迭代遍历.
void traverse(struct TreeNode *root) { if (root) { /* 1 */ traverse(root-&amp;gt;left); /* 2 */ traverse(root-&amp;gt;right); /* 3 */ } } 上面的 1, 2, 3 三个位置是节点访问可能发生的位置, 分别为先序, 中序, 后序遍历. 下面我们不考虑对节点数据的访问, 单独分析一下递归遍历过程的细节.
函数调用与递归的本质 要分析递归遍历的细节, 我们就要知道递归的过程中发生了什么, 而递归实际上也只是函数调用的一种, 所以我们需要先来看一下函数调用的过程中发生了什么.
当函数调用发生时, 传给该函数的参数, 以及被调函数内部的局部变量都会被压入栈中 (现在的处理器和编译器基本都支持通过寄存器传参, 这里我们没必要考虑这些个情况), 而在被调函数返回时, 这些信息又都会从栈中弹出. 递归只是一种自己调用自己的函数调用, 也是符合这个规则的.
我们以上面的 traverse(struct TreeNode *root) 方法和下面的一颗二叉树为例, 观察一下递归遍历过程中的栈变化.
A / \ B C / \ / \ D E F G 其中 A 是根节点, 遍历过程由 traverse(root) 被调用开始, 那么按照上述的规则, 会发生如下几步, 为方便起见, 栈的增长为从左往右:</description></item><item><title>关于 OpenFlow 协议中 Instruction, Action 概念的解读</title><link>https://cifer97.github.io/posts/openflow-instruction-action/</link><pubDate>Mon, 03 Oct 2016 21:45:30 +0000</pubDate><guid>https://cifer97.github.io/posts/openflow-instruction-action/</guid><description>(首发于 sdnlab: http://www.sdnlab.com/17952.html)
阅读任何一个协议都要注意的一点是这个协议中所定义的专有术语, 对这些术语的理解不到位的话也会造成对协议的理解偏差. 本文想和大家分享几个可能容易混淆的术语.
在 OpenFlow 协议文档中经常会看到这么几个词语: Instruction, Action, Apply-actions, Action Set, Action List, Clear-actions, &amp;hellip; 有点迷惑人, 实际上这里面只有两个实体的概念: Instruction 和 Action. 为了保持后文的易读性, 这两个概念分别用中文 &amp;ldquo;指令&amp;rdquo; 和 &amp;ldquo;动作&amp;rdquo; 来描述. 下文中的 &amp;ldquo;指令&amp;rdquo; 和 &amp;ldquo;动作&amp;rdquo; 都特指在 OpenFlow 协议中的含义.
指令这个词, 特指流表表项中的指令, 当某个报文匹配了这个表项之后, 表项中的指令就会被应用于这个报文; 而动作是比指令更细粒度的概念, 但它并不是局限于流表表项的概念, 动作可以独立于指令而存在, 也可以被包含在指令中, 具体说来, 我们在下流表的时候, 可以为某个表项的某种指令指定一些列的动作, 但是动作并不是只有下流表的时候才会被用到.
本文以目前较新的 Openflow 1.4 版本为准, 来分别看一下指令和动作的含义.
指令 每一个流表的表项都包含一系列的指令, 当报文匹配上了这个表项后, 这些指令就会被执行, 这些指令的执行结果有几种: 改变报文, 改变 action set, 改变 pipeline. 这些指令可以按照其执行结果的不同而分类, 不同的流表的表项包含的指令种类也不同, 前面说了指令可以包含动作, 但也并非所有种类的指令都包含动作, 下面我们一起来看一下指令的分类.
指令的分类 OpenFlow 1.</description></item><item><title>(译) 如何使用 C 语言中的 volatile 关键字</title><link>https://cifer97.github.io/posts/c-volatile/</link><pubDate>Sat, 07 Nov 2015 21:01:45 +0000</pubDate><guid>https://cifer97.github.io/posts/c-volatile/</guid><description>(原文: http://www.barrgroup.com/Embedded-Systems/How-To/C-Volatile-Keyword, 已取得翻译许可)
很多 C 程序员都不真正懂得 volatile 关键字的用法. 这无需奇怪, 因为大多数的 C 教程对 volatile 的介绍都比较简单. 这篇文章的目的就是告诉你 volatile 的正确使用方式
你有碰到过下面的几个情形吗?
代码编译运行没问题 &amp;mdash; 直到你打开了编译器优化 代码运行的很好 &amp;mdash; 直到一个中断发生 古怪的硬件驱动程序 RTOS task 各自单独运行时很好 &amp;mdash; 直到有其它 task 被 spawned 如果你碰到过上述任何一个问题, 那么就可能是你没有使用 volatile 关键字的原因. 你并不孤单, volatile 关键字为很多程序员所不熟悉. 不幸的是, 很多 C 相关的书籍都没有好好的介绍 volatile 关键字.
volatile 关键字和 const 一样, 是一个限定符, 用于一个变量被声明时. 它告诉编译器, 被声明的变量的值可能随时都会被改变 &amp;ndash; 就算使用这个变量的代码的附近 (附近有多近, 要看编译器了, 可能是同一个源文件) 没有任何修改这个变量值的语句也是如此. 给编译器的这个暗示是很严肃的, 在我们继续讲解之前, 我们先来看一下 volatile 的语法.
volatile 关键字的语法 要将一个变量声明为 volatile 的, 需要在声明时将 volatile 关键字写到数据类型关键字的前面或后面.</description></item><item><title>PAM, su 以及 wheel 用户组</title><link>https://cifer97.github.io/posts/pam-su-wheel-group/</link><pubDate>Sat, 02 May 2015 11:27:31 +0000</pubDate><guid>https://cifer97.github.io/posts/pam-su-wheel-group/</guid><description>在我的 gentoo 系统下, su 使用 pam 模组, 要求只有处于 wheel 用户组的普通用户才能够使用 su 切换到 root 用户的权限. 如果你查看 /etc/pam.d/su, 可以看到下面这一行:
auth required pam_wheel.so use_uid 但是 GNU su 不支持 wheel 用户组, 也就是说, 如果你使用的是 GNU su, 那么当你 (普通用户) 执行 GNU su 来切换到 root 权限时, GNU su 不会检查你是否是 wheel 用户组的一员, 只要你给出了 root 用户的密码就能够切换成功.
这是怎么实现的呢, 可以看出, 上面那一行 pam 规则中, flag 值用的是 required, required 这个值在这里表示不管 pam_wheel.so 模块的检查结果是成功还是失败, 后续的检查都会继续运行下去, 那么 GNU su 只要忽略 pam_wheel.so 的检查结果就可以了. 而其他的 su 实现, 则不会忽略 pam_wheel.</description></item><item><title>openocd 基础与百问网的 openjtag 介绍</title><link>https://cifer97.github.io/posts/openocd-and-openjtag/</link><pubDate>Sun, 12 Apr 2015 15:24:03 +0000</pubDate><guid>https://cifer97.github.io/posts/openocd-and-openjtag/</guid><description>使用 openocd 的话, 最好是先看看 openocd 的官方手册, 100 多页, 不需要全看, 但是基本, 核心的概念要了解, 比如说 debug adapter/adapter, interface, target, board 等.
Adapter 与 Interface 配置文件 debug adapter 或者直接叫做 adapter 呢, 就是指的你所使用的调试适配器, 一般来说就是 jtag 适配器了, 它会通过 JTAG 口与连接到开发板上, 比如 segger 家的 jlink, 开源的硬件项目 openjtag 等等.
使用不同的 adapter, 就需要在启动 openocd 时指定不同的 interface 文件, 这基本上是告诉 openocd 我的 adapter 用到了什么样的硬件, 参数是怎样的, 这样 openocd 才知道怎么和 adapter 通信, 因为 openocd 支持的 adapter 类型, 也就是支持的硬件设备类型太多了. 如果你写一个程序, 只支持 pl2303 类型的 usb-serial 设备, 那自然不需要像 openocd 那么复杂的配置了.</description></item><item><title>PEAR 与 PECL 介绍</title><link>https://cifer97.github.io/posts/php-pear-pecl/</link><pubDate>Mon, 09 Feb 2015 09:39:30 +0000</pubDate><guid>https://cifer97.github.io/posts/php-pear-pecl/</guid><description>PEAR PEAR 全称是 PHP Extension and Application Repository, 和水果 &amp;ldquo;梨&amp;rdquo; 的英文发音是相同的. PEAR 存在的目的是:
提供一个有组织结构的开源代码仓库给 PHP 用户们 提供一个代码发布以及包维护的系统 制定一份 PHP 代码风格规范 (在这里: http://pear.php.net/manual/en/standards.php) 运作 PHP Extension Community Lbrary (PECL) 姐妹组织 维护相关的网站, 邮件列表, 源镜像, PEAR/PECL 社区 PEAR 是一个社区驱动的组织, 由开发者管理. PEAR 的使命 PEAR 的使命就是为 PHP 用户提供良好可重用的组件 (避免让用户自造轮子), 以及领导 PHP 革新, 努力为 PHP 开发者提供最佳的开发体验.
由 PHP 书写的结构良好的代码库以及应用 PEAR 中的代码以 &amp;ldquo;包&amp;rdquo; 为单元. 每一个包都是一个独立维护的项目, 有专门的开发团队, 有自己的版本号, 发布周期, 项目文档, 以及与其他包的依赖关系信息.
PEAR 中的包都是以 gzip tar 档案格式发布的. 在你的系统上, 你可以使用 &amp;ldquo;PEAR installer&amp;rdquo; (http://pear.</description></item><item><title>Pathinfo 和 Nginx</title><link>https://cifer97.github.io/posts/pathinfo-and-nginx/</link><pubDate>Fri, 30 Jan 2015 16:27:31 +0000</pubDate><guid>https://cifer97.github.io/posts/pathinfo-and-nginx/</guid><description>不知为何, Nginx 中配置 PATH_INFO 似乎一直以来是一件不那么明朗的事情, 在网上搜索的话, 会搜到各种各样的配置方式. 很多都是网友们自己 &amp;ldquo;发明&amp;rdquo; 的. 各大发行版安装好了 Nginx 之后, 默认也是没有配置对 PATH_INFO 的支持的, 怎么会这样呢? 难道 Nginx 就没有一个官方的解决方案吗?
自然是有的.
PATH_INFO 是 CGI 1.1 标准中规定的一个变量, 在 www 服务器委托 CGI 脚本执行任务时, 需要传递给 CGI 脚本的信息. 这么重要的一个变量, Nginx 当然是会支持的. 参考一中就是官方的方案. 我们在这里重复一下.
首先我们知道, 在 nginx 中, 是可以使用 nginx 自带的一些命令, 给 CGI 1.1 中规定的那些变量赋值的, 而这些命令默认都位于 /etc/nginx/fastcgi.conf 或者 /etc/nginx/fastcgi_params 文件里, 在配置 fastcgi 程序处理我们的请求时, 只要在 nginx 中包含这个两个文件之一, fastcgi 程序就能够取得所需要的变量. 在我的系统上, /etc/nginx/fastcgi.conf 文件是这样的:
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_param REQUEST_URI $request_uri; fastcgi_param DOCUMENT_URI $document_uri; fastcgi_param DOCUMENT_ROOT $document_root; fastcgi_param SERVER_PROTOCOL $server_protocol; fastcgi_param HTTPS $https if_not_empty; fastcgi_param GATEWAY_INTERFACE CGI/1.</description></item><item><title>Linux C 中如何正确的判断一个文件/目录文件是否存在</title><link>https://cifer97.github.io/posts/howto-detect-file-exists/</link><pubDate>Sun, 06 Apr 2014 14:59:00 +0000</pubDate><guid>https://cifer97.github.io/posts/howto-detect-file-exists/</guid><description>source: http://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c-cross-platform
其实不光是在 Linux 下编程, 在其他平台下我们都会有这样的需求: 我们要为应用程序创建自己的数据或者日志目录, 应用程序在每次启动时会检查文件系统中是否已经有了自己的目录, 没有的话就创建它, 有了的话就跳过这一步. 那么如何去判断文件系统中是否已经存在了要创建的目录呢?
Linux 或者 GNU C 都没有提供一个像 file_exists() 这样直观的系统调用给我们, 所以我们得通过其它的调用来达成这个目标.
实际上当我第一次要解决这个问题时, 我先 google 了一下, 这个问题在 stackoverflow 上有人问过而且非常受欢迎, 很多人对这个问题又点赞又收藏的, 自然, 这个问题也收到了不少好的答案, 这篇文章算是对这些好答案的总结和延伸.
我们先来看一个大家都应该知道的方式, 第一种方式:
fopen() fopen() 方法是流阶级的方法, 这个方法接收用户提供的文件名, 以及访问方式, 然后尝试着打开文件, 打开成功则返回 handle, 失败则返回 NULL. 因此有人提出了使用这个方法来判断指定的文件是否存在的方案:
#include &amp;lt;stdio.h&amp;gt; ... FILE *fp = NULL; fp = fopen(&amp;quot;/tmp/test/somefile&amp;quot;, &amp;quot;r&amp;quot;); if(fp) { // exists } else { // not exists } fclose(fp); 这也是 stackoverflow 上唯一一个得负分的答案, 这个方案的问题在于它没有考虑到文件权限的问题, 而 fopen() 这个函数又是如此的简单 &amp;mdash; 不管因为什么原因打开文件失败了, 它只是返回 NULL 给你, 不会提供更多的错误信息.</description></item><item><title>搞定 HP MicroServer 的 Smart Array Controller B120i 磁盘阵列, 在安装 RHEL 时</title><link>https://cifer97.github.io/posts/work-through-raid-in-rhel/</link><pubDate>Wed, 22 Jan 2014 09:48:00 +0000</pubDate><guid>https://cifer97.github.io/posts/work-through-raid-in-rhel/</guid><description>MicroServer Gen8 是 HP 服务器里较新的一个系列, 其所配备的磁盘阵列卡 &amp;mdash; Smart Array Controller B120i, 也是比较新的一种阵列卡, 目前 HP 仅提供了 RHEL, OpenSUSE, Microsoft 的驱动程序.
我们就是要在 MicroServer Gen8 上安装 RHEL6.
MicroServer Gen8 的主板上的 ROM 上搭在了一个小型的配置系统, 叫做 Intelligence Provisioning, 在这里你可以对磁盘阵列进行分区(正如 hardware raid 都会带有一个控制系统来管理自己的说法一样), 还可以配置你要安装的操作系统(不过在通过这个配置你可以安装的系统有限, 仅限于 HP 提供了阵列卡驱动的那些系统), 还带了一些系统健康状态监控的功能.
对于上述的几个可以在 Intelligence Provisoning 中配置的操作系统, MicroServer Gen8 似乎都提供了他们的安装程序, 这点比较方便, 因为在 Intelligence Provisioning 中配置好我们想安装的操作系统之后, 重启机器就回进入这个操作系统的安装界面, 然后你只需要提供操作系统的镜像就可以继续你的安装. 但是 Gen8 预置的 RHEL 操作系统安装程序却是有一个严重的不如人意的地方, 稍候我会说明这一点.
众所周知, 安装软件时, 一般来说这个软件会提供一个安装程序, 我记得 windows 下以前最火的制作安装程序的软件叫 InstallShield 不知现在还是不是最火的, 使用这个软件就可以制作出那种傻瓜化的一路下一步的软件安装程序, 而 linux 下的安装程序, 应该就得算各种包管理系统或者是.</description></item><item><title>书单</title><link>https://cifer97.github.io/reading/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/reading/</guid><description>2021 New Concept English 3 经济学原理 - 曼昆 聪明的投资者 - 格雷厄姆, 价值投资的鼻祖, 笔记 伯克希尔年报 - 巴菲特 资本回报 - 马拉松基金 2020 and earlier Data Structures and Algorithm Analysis in C, 2nd edition The C Programming Language (aka. K &amp;amp; R C), 2nd edition, K &amp;amp; R C 第一版是 C 语言历史上的第一个 &amp;ldquo;事实标准&amp;rdquo;, 而这第二版则是在 ANSI C89 标准出来之后对第一版的修订, 目前在网上能够找到的也是这个版本. Expert C Programming, Deep Secrets See MIPS Run, 2nd edition, 少有的将处理器架构和操作系统结合起来讲的书, 而且作者的写作思想和我完全一致, 绝世好书!</description></item><item><title>投资理念</title><link>https://cifer97.github.io/investingrule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/investingrule/</guid><description>准则 和其他任何事情一样, 买股票的法则越简单越好, 不要花里胡哨.
不要选自己不了解的企业 不管是格雷厄姆和巴菲特所倡导的价值投资
不要因为便宜就选垃圾股 就如巴菲特说, &amp;ldquo;我最好的三个股票可能和大部分的投资人差不多, 但可能我最差的三个股票要比其他投资人好得多&amp;rdquo;. 保持持股数在 10 ~ 30 只之间, 同时保持这些股票足够的不相关 很多行业看起来不同, 但其实相关性很高, 这样就没有意义. 选择财务稳健的企业 这意味着企业产生自由现金流的能力很强, 因此偿债能力也很强, 甚至不需要过分融资或借贷. 选择有确定性的企业 &amp;ldquo;从确定性投资来说，我更多会从行业的供给端、竞争格局找到未来可持续的东西。能确定的东西不多，但我们能找到确定性的东西。我们也不需要找到很多，找到几个就足够了&amp;rdquo; (引用自张坤 2020.06 的采访) 选择尚未被高估的企业 格雷厄姆的方法是用过去 7 年里每股收益的平均数计算市盈率, 选择市盈率 25 倍的企业. (这是比较保守的策略, 因为这会剔除大部分的成长股, 可适当提高市盈率的门槛) 选择持续支付股息的企业 持股首先是为了享受股东的分红权益, 其次是享受股价上升的收益. 选择有较强议价能力的企业. 买一个公司，一定要看在谈判过程当中，谁是敢掀桌子的那边，谁更不依赖谁，谁更不怕这个合同做不成，谁更难找到替代者. (引用自张坤 2020.06 的采访) 技巧 如果拿过一家企业, 不确定它是不是好, 就与同行业其他企业进行比较 如果当前处于顺周期阶段, 那就考虑如果剔除行业景气带来的加成, 企业能否自己表现的很好 参考选股步骤 张坤 1
首先，筛选出历史上自由现金流强劲、ROIC持续稳定、有息负债率低、没有反复股权融资历史的企业，这一步做完之后大约有200-300家左右的企业。 其次，阅读每个企业从上市以来的所有年报，剔除掉壁垒正在丧失、竞争力在削弱的企业，留下的企业都在持续观察的名单中。之后，会在这批企业遇到短期困难而不影响长期竞争力时果断介入。
张坤 2
张坤初选的第一步是看财务指标，要求公司在较长时间内，比如过去5至10年，平均ROIC不低于10%且没有大幅波动。 接下来，张坤则是剔除高杠杆的公司，比如有息负债率过高、或有频繁股权融资的历史。不喜欢商业模式上有大量负债的重资产类公司，喜欢那些依靠自身诚实经营积累现金流成长起来的、内生性成长的公司。 第三步，张坤会排除掉行业中地位不够高、对上下游议价能力不强、营运资本高的企业。经过这一轮筛选后，剩下不多的几百家公司，张坤会花大量时间去研究。</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程笔记</title><link>https://cifer97.github.io/</link><description>Recent content on 编程笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 05 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer97.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>&lt;&lt;价值>> 读书笔记</title><link>https://cifer97.github.io/reading-notes/jiazhi/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/reading-notes/jiazhi/</guid><description>走进耶鲁捐赠基金 国外名校的捐赠基金一直是他们重要的收入来源, 也是各私募机构重要的资金来源. 私募的其他资金来源还包括社保基金, 养老基金, 慈善基金, 家族基金. 这些都是都是长期资金, 不要求短期收益率, 所以是</description></item><item><title>穷查理宝典 - 查理·芒格智慧箴言录</title><link>https://cifer97.github.io/reading-notes/poor-charlies-almanack-notes/</link><pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/reading-notes/poor-charlies-almanack-notes/</guid><description>如果说格雷厄姆的 聪明的投资者 教会我们去购买便宜的股票, 查理则教我们突破这一局限.</description></item><item><title>聪明的投资者笔记</title><link>https://cifer97.github.io/reading-notes/the-intelligent-investor-notes/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/reading-notes/the-intelligent-investor-notes/</guid><description>第 5 章 防御型投资者与普通股 首先格雷厄姆给出了防御性投资者投资普通股的 4 条准则 &amp;mdash; 都是很保守的准则. 然后格雷厄姆说明了不建议防御型投资者投资成长股. 最后推荐了一种特别适合防御性投资者的投资方式: 美元成本平</description></item><item><title>2020 年终总结</title><link>https://cifer97.github.io/posts/year-in-review-2020/</link><pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/year-in-review-2020/</guid><description>2020 年终总结 个人性格 始终还是优柔寡断的性格, 2021 年一定要改变这个性格. 工作 对管理有了一些思考, 一个管理者应该具备真正的资源把控能力, 而不应该单纯的就是派活给团队成员, 更不应该是 &amp;ldquo;拿着鞭子&amp;rd</description></item><item><title>Rust 里的单例模式</title><link>https://cifer97.github.io/posts/rust-singleton/</link><pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/rust-singleton/</guid><description>Rust 要想搞个单例模式还真是曲折. 单例模式说到底就是全局变量, 在别的语言很容易实现, 但是在 rust 里则诸多不便, 因为 rust 这门语言从设计上就是要避免使用全局变量的. 实际上 Rust 里就没有全局变量的概念, 只有生命周期的概念</description></item><item><title>AWS Implementation of Redis Cluster</title><link>https://cifer97.github.io/posts/aws-redis-cluster/</link><pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/aws-redis-cluster/</guid><description>AWS redis cluster topology Refer to [2]
Number of connections to master and slave nodes For each node there are two connection related metrics: NewConnections and CurrConnections.
NewConnections, AWS ElastiCache derives this by subtracting two consecutive samples of the total_connections_received stats of a redis node. CurrConnections, this metric is derived directly from the redis stats connected_clients which contains the number of client connections(excluding the connections from replicas) Redirect &amp;gt; Normally slave nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use slaves in order to scale reads using theREADONLY command.</description></item><item><title>浏览器追踪技术与防范</title><link>https://cifer97.github.io/posts/browser-tracking/</link><pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/browser-tracking/</guid><description>Cookie 这里说的就是我们通常所熟知的 cookie，很多第三方公司就是借助这种 cookie 实现追踪的。比如网站 A，B 都使用了 DoubleClick 的 js 脚本，DoubleClick 的脚本在用户访问网站 A 时被加载并埋下 cookie，下次用户访</description></item><item><title>对解释器与 JIT 的一点思考</title><link>https://cifer97.github.io/posts/jit/</link><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/jit/</guid><description>我一直知道解释器与编译器的区别. 编译器是事先将代码编译成机器码, 然后直接送进内存让 cpu 执行, 解释器则是解释执行代码, 可能会将代码先转换成一种中间码, 但我一直有一个误区就是解释器在解释执行的时候会把源代码</description></item><item><title>对协程的一点认识</title><link>https://cifer97.github.io/posts/coroutine/</link><pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/coroutine/</guid><description>协程的调度 我们知道线程是 CPU 的基本调度单元，线程调度靠的是时钟中断. 协程是执行于线程之内的更细粒度的执行单元，他的调度无法依赖时钟中断，而是要靠一个用户态的调度器，这个调度器可以是抢占式或非抢占式，抢占</description></item><item><title>DPoS 核心概念</title><link>https://cifer97.github.io/posts/dpos/</link><pubDate>Thu, 04 Oct 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/dpos/</guid><description>本文基于 BM 的唯二的两篇阐述 DPoS 机制的文章, 第一篇文章是 BM 首次提出 DPoS 共识机制, 第二篇是 BM 后来对 DPoS 机制补充的白皮书. 两篇文章的链接见文末. 最近精读了这两篇文章, 从中提炼出了以下我认为是最核心的内容. 见证人选</description></item><item><title>C++ 的左右值与左右值引用</title><link>https://cifer97.github.io/posts/c-plus-plus-reference/</link><pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/c-plus-plus-reference/</guid><description>左值与右值 C++ 中左值和右值的概念来源于 C, 在 C 中左值和右值的区别很简单, 能出现在赋值号左侧的就是左值, 否则就是右值. 比如变量是左值, 字面常量或者 const 定义的常量是右值. 然而在 C++ 中, 左值和右值的区别就不再是那么</description></item><item><title>如何在应用层控制最大客户端连接</title><link>https://cifer97.github.io/posts/controlling-client-connections/</link><pubDate>Fri, 23 Feb 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/controlling-client-connections/</guid><description>当有客户端连接, 而程序中没有去处理时, select 就回持续不断的返回这个文件描述符可写, 例如, 下面是我以前写的一段有 bug 的程序: int csocks[MAX_CONNECTION]; memset(csocks, -1, MAX_CONNECTION * sizeof(int)); FD_SET(sock, &amp;amp;rset); while(1) { if (select(FD_SETSIZE, &amp;amp;rset, NULL, NULL, NULL) &amp;lt;= 0) { return ; } if (FD_ISSET(sock, &amp;amp;rset)) { // looking for an unused socket for (int i = 0 ; i &amp;lt; MAX_CONNECTION;</description></item><item><title>C 语言宏的展开与字符串化宏和符号连接宏</title><link>https://cifer97.github.io/posts/c-macro/</link><pubDate>Tue, 20 Feb 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/c-macro/</guid><description>C 语言由于没什么高级的特性, 所以现有的特性被玩的各种精. 宏展开就是很值得品味的部分. 递归展开问题 宏定义语句是这样的: #define identifier token-sequence 在具体的宏展开过程中, 遇到标识符时, 此标识符会整个的被使用 token-sequence 展开, 如果 token-sequence 中还包</description></item><item><title>国富论笔记</title><link>https://cifer97.github.io/reading-notes/the-wealth-of-nations-notes/</link><pubDate>Tue, 16 Jan 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/reading-notes/the-wealth-of-nations-notes/</guid><description>货币的出现以及金属作为货币的原因 稳定而不易磨碎 容易分割和重铸 铸币制度以及造币局官衙的产生 金属货币的两大问题: 1. 称重 2. 验纯 这两项技术不达标, 导致假币猖獗. 物品的使用价值与交换价值 过去人民自给自足, 自产粮</description></item><item><title>比特币的多重签名技术与实践</title><link>https://cifer97.github.io/posts/bitcoin-multisig/</link><pubDate>Sat, 06 Jan 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/bitcoin-multisig/</guid><description>Multisignature scripts set a condition where N public keys are recorded in the script and at least M of those must provide signatures to unlock the funds. This is also known as an M-of-N scheme, where N is the total number of keys and M is the threshold of signatures required for validation &amp;lt;精通比特币&amp;gt; 多重签名首次规范化提出是在 BIP11, 它添加了一种新的交易类型 OP_CHECKMULTISIG, 这种交易的锁定</description></item><item><title>论铸币制度与比特币多中心化</title><link>https://cifer97.github.io/posts/bitcoin-currency/</link><pubDate>Sat, 06 Jan 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/bitcoin-currency/</guid><description>货币起源 在人类文明发展史上, 由于物物交换的不便而产生了一般等价物, 金银等金属由于其不易损耗而又能够分割并重熔的特性成为备受认可的一般等价物 &amp;mdash; 货币. 铸币制产生 金属作为货币并没有改变贝壳, 石头作为货币时的</description></item><item><title>2017 年终总结</title><link>https://cifer97.github.io/posts/year-in-review-2017/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/year-in-review-2017/</guid><description>学习 学会了使用 python 写简单的工具 从盛科辞职, 加入了滴滴 研究数字货币, 研究的很深. 投资了 HPB, BTS 和 STEEM 人生 结婚 在一沿海二线城市买了方, 买的时候已经不便宜了 浪费时间的瞎折腾 emacs, orgmode 为了使用 orgmode, 不得不学习折腾 emacs, 要是早点发现</description></item><item><title>比特币隐私加固 - CoinJoin 技术简析</title><link>https://cifer97.github.io/posts/bitcoin-coinjoin/</link><pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/bitcoin-coinjoin/</guid><description>思想 由 @gmaxwell 在 CoinJoin: Bitcoin privacy for the real world 一文提出. 核心思想就是利用比特币的一笔交易中可以有多个输入以及多个输出这一点, 将多笔交易合并, 使得让人难以分辨哪笔输入对应哪笔输出, 进而达到难以追踪某个地址的资金的来源或去向的</description></item><item><title>关于 Python 中的 time 与 datetime 模块</title><link>https://cifer97.github.io/posts/python-time-datetime/</link><pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/python-time-datetime/</guid><description>在 Python 中处理时间有两个库可用: time 和 datetime, 这两个模块曾经在很长一段时间里困扰着我, 我觉得这是 Python 又一处矛盾的地方 (最大的矛盾是 3 和 2 不兼容), 因为一门对开发者友好的语言应该直接提供最好用的库, 而不是让开发者去做</description></item><item><title>再论个人知识管理</title><link>https://cifer97.github.io/posts/knowledge-management/</link><pubDate>Sat, 18 Nov 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/knowledge-management/</guid><description/></item><item><title>FreeRTOS 的链表 vListInsertEnd() 方法笔记</title><link>https://cifer97.github.io/posts/freertos-vlistinsertend/</link><pubDate>Thu, 16 Nov 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/freertos-vlistinsertend/</guid><description>在研究 FreeRTOS 内核时, 发现自已一直理解错了 vListInsertEnd() 的意思, 特此记录下. vListInsertEnd() 这个方法比较迷惑人, 这个方法真正的意思是尾插, 而不是插到链表的尾部. 这两者的意思是不一样的. 那究竟什么是尾插呢? 我们应该知道头插, 给定一个链</description></item><item><title>通俗地解释 CGI, FastCGI, php-fpm 之间的关系</title><link>https://cifer97.github.io/posts/cgi-fastcgi-php-fpm/</link><pubDate>Thu, 09 Nov 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/cgi-fastcgi-php-fpm/</guid><description>这要了解一点万维网 (WWW) 的历史, 才能更好地了解个中关系. 早期的网站基本都是静态的, 那时候的 web server 几乎所有工作就是给访问者提供静态资源, 网站与访问者之间缺乏交互. 后来随着 WWW 的发展网站变得交互性强了起来, 交互性</description></item><item><title>什么是比特币的链上 (on-chain) 与链下 (off-chain) 交易, 以及往交易所充币后发生了什么</title><link>https://cifer97.github.io/posts/bitcoin-on-off-chain/</link><pubDate>Tue, 07 Nov 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/bitcoin-on-off-chain/</guid><description>on-chain on-chain 就是比特币的常规交易方式: 给我一个比特币地址 (公钥), 我用客户端创建交易发送比特币给你, 这笔交易在全网广播, 被确认, 被打包进区块. 显然, 交易是直接发生在链上的. off-chain 至于 off-chain 其实玩过比特币的人也都用过,</description></item><item><title>深入解读同步/异步 IO 编程模型</title><link>https://cifer97.github.io/posts/io-programming/</link><pubDate>Mon, 06 Nov 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/io-programming/</guid><description>所谓 &amp;ldquo;同步&amp;rdquo; 和 &amp;ldquo;异步&amp;rdquo; 是从调用者的角度来说的. 如果调用者不得不等待 IO 完成才能执行后续的工作, 那就是同步; 否则, 就是异步. 这是我对 &amp;ldquo;同步&amp;rd</description></item><item><title>说一说重放, 重放保护, 以及分叉期间我们该怎么做</title><link>https://cifer97.github.io/posts/bitcoin-replay/</link><pubDate>Tue, 24 Oct 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/bitcoin-replay/</guid><description>何为重放 先说重放, 重放指的是分叉过后, 由于新链和旧链所运行的协议可能完全兼容, 导致在旧链上发生的交易拿到新链上也是合法的. 以本次的即将上演的 BTC/BTG 分叉为例: 在高度 A 左右我们生成了两个新地址 a, b. 然后在高度 B</description></item><item><title>闲聊即将到来的 segwit2x 分叉</title><link>https://cifer97.github.io/posts/segwit2x/</link><pubDate>Mon, 23 Oct 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/segwit2x/</guid><description>早些时候由矿工主导的 &amp;ldquo;纽约共识&amp;rdquo; 达成了 segwit2x 方案, 约定在 2017 年 9 月以前启动隔离见证, 并在随后的 3 - 6 个月内启动 2mb 扩容. 所以 segwit2x 这个名字起的有意思, 看着好像跟 segwit 2.0 版一样, 实际上 segwit2x 指包含两</description></item><item><title>Electrum 钱包的 sweep 功能小记</title><link>https://cifer97.github.io/posts/electrum-sweep/</link><pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/electrum-sweep/</guid><description>electrum 是款优秀的 bitcoin 轻钱包, bitcoin.org 的文章里经常有提到它, 可见 bitcoin.org 除了自己的 core 钱包之外还是比较推荐 electrum 的. 使用 electrum 钱包时, 建议的生成私钥的方式是从 seed 生成, 这样所有生成的密钥都是可以从 seed 推算出来的, 对钱包的备份也就简化为</description></item><item><title>Bitshares 中的账户与权限个人理解</title><link>https://cifer97.github.io/posts/bitshares-account-mechanism/</link><pubDate>Sat, 16 Sep 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/bitshares-account-mechanism/</guid><description>单一账户模型 在这个模型下, 我们提供一个登录名以及密码, 系统会根据登录名+密码生成确定的私钥, 所以用这种模式创建的账户, 可以在任何设备上用登录名+密码登录. 钱包模型 钱包模型的好处是, 钱包可以包含多个账户</description></item><item><title>比特币地址, 公钥与私钥的格式以及如何保证比特币不丢失</title><link>https://cifer97.github.io/posts/what-is-bitcoin-address-how-to-protect-it/</link><pubDate>Fri, 01 Sep 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/what-is-bitcoin-address-how-to-protect-it/</guid><description>我们知道在公钥加密体系中, 由私钥推出公钥很容易反过来却是不可能的, 借助一些伟大的数学算法可以实现这一特性, 比特币使用的算法叫做椭圆曲线算法. 在比特币中私钥就是一个 256bit 的数字, 得到这个数字的方法有很多, 最</description></item><item><title>Solidity 的编译器们</title><link>https://cifer97.github.io/posts/compilers-of-solidity/</link><pubDate>Sun, 20 Aug 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/compilers-of-solidity/</guid><description>solidity 是当下 ethereum 最流行的智能合约开发语言, 语法类似于 javascript. 要使用它写智能合约的话, 我们还需要一个编译器, 用来将 solidity 的代码编译为 EVM 字节码. solidity 的编译器有多种实现, 下面可以一起看一看. solc 一般说到 solc 指的都是 ethereum 官方实现的 cpp</description></item><item><title>2016 年终总结</title><link>https://cifer97.github.io/posts/year-in-review-2016/</link><pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/year-in-review-2016/</guid><description>这是一篇拖了相当久的总结, 2016 年是我动荡不安的一年. 辞职 首先是 6 月份的辞职, 这是我在 Y 工作整整三年来的辞职. 那个时候我的脑中存在着不知从哪听到的一个观念: 三年是一个阶段, 在一家公司工作满三年了就可以跳槽</description></item><item><title>写在入职滴滴的前夕</title><link>https://cifer97.github.io/posts/acquired-by-didi/</link><pubDate>Mon, 20 Mar 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/acquired-by-didi/</guid><description>明天 (3.21) 就正式入职滴滴了, 这对我来说是非常值得开心的, 然而我这些天却越发的感觉到几丝迷茫. 现在想想, 从上了大学起, 我精神就一直处于一个懒散的状态, 整个大学里没有一点危机意识, 没有去思考我该做什么, 想要什</description></item><item><title>记一次 Indigo 与 Ryu 的连接建立问题</title><link>https://cifer97.github.io/posts/a-problem-ryu-indigo-conn-setup/</link><pubDate>Sun, 25 Dec 2016 16:03:13 +0000</pubDate><guid>https://cifer97.github.io/posts/a-problem-ryu-indigo-conn-setup/</guid><description>之前在研究 Indigo 和 Ryu 的衔接时碰到一个 OpenFlow 连接建立失败的问题, 特此记录下, 希望能够供别人参考. 在了解这个问题之前, 我们先回顾一下 OpenFlow 连接建立过程. OpenFlow 协议的连接建立过程 根据 OpenFlow 协议标准的陈述我们能够知道, 交换机和控</description></item><item><title>二叉树递归遍历的本质以及用迭代遍历精确模拟递归遍历</title><link>https://cifer97.github.io/posts/binary-tree-traversal/</link><pubDate>Sat, 22 Oct 2016 17:24:36 +0000</pubDate><guid>https://cifer97.github.io/posts/binary-tree-traversal/</guid><description>递归遍历是实现深度优先遍历的既直观又简单的方式, 二叉树递归遍历的本质其实就是在不断的压栈与出栈, 明白了这一道理之后就很容易借助栈结构来将递归遍历转换成迭代遍历. void traverse(struct TreeNode *root) { if (root) { /* 1 */ traverse(root-&amp;gt;left); /* 2 */ traverse(root-&amp;gt;right); /* 3 */ }</description></item><item><title>关于 OpenFlow 协议中 Instruction, Action 概念的解读</title><link>https://cifer97.github.io/posts/openflow-instruction-action/</link><pubDate>Mon, 03 Oct 2016 21:45:30 +0000</pubDate><guid>https://cifer97.github.io/posts/openflow-instruction-action/</guid><description>(首发于 sdnlab: http://www.sdnlab.com/17952.html) 阅读任何一个协议都要注意的一点是这个协议中所定义的专有术语, 对这些术语的理解不到位的话也会造成对协议的理解偏差. 本文想和大家分享几个可能容易混淆的术语. 在 OpenFlow 协议文档中经常会看到这么几个词语</description></item><item><title>(译) 如何使用 C 语言中的 volatile 关键字</title><link>https://cifer97.github.io/posts/c-volatile/</link><pubDate>Sat, 07 Nov 2015 21:01:45 +0000</pubDate><guid>https://cifer97.github.io/posts/c-volatile/</guid><description>(原文: http://www.barrgroup.com/Embedded-Systems/How-To/C-Volatile-Keyword, 已取得翻译许可) 很多 C 程序员都不真正懂得 volatile 关键字的用法. 这无需奇怪, 因为大多数的 C 教程对 volatile 的介绍都比较简单. 这篇文章的目的就是告诉你 volatile 的正确使用方式 你有碰到过下面的几个情形吗? 代码编译运行没</description></item><item><title>PAM, su 以及 wheel 用户组</title><link>https://cifer97.github.io/posts/pam-su-wheel-group/</link><pubDate>Sat, 02 May 2015 11:27:31 +0000</pubDate><guid>https://cifer97.github.io/posts/pam-su-wheel-group/</guid><description>在我的 gentoo 系统下, su 使用 pam 模组, 要求只有处于 wheel 用户组的普通用户才能够使用 su 切换到 root 用户的权限. 如果你查看 /etc/pam.d/su, 可以看到下面这一行: auth required pam_wheel.so use_uid 但是 GNU su 不支持 wheel 用户组, 也就是说, 如果你使用的是 GNU su, 那么当你 (普通用</description></item><item><title>openocd 基础与百问网的 openjtag 介绍</title><link>https://cifer97.github.io/posts/openocd-and-openjtag/</link><pubDate>Sun, 12 Apr 2015 15:24:03 +0000</pubDate><guid>https://cifer97.github.io/posts/openocd-and-openjtag/</guid><description>使用 openocd 的话, 最好是先看看 openocd 的官方手册, 100 多页, 不需要全看, 但是基本, 核心的概念要了解, 比如说 debug adapter/adapter, interface, target, board 等. Adapter 与 Interface 配置文件 debug adapter 或者直接叫做 adapter 呢, 就是指的你所使用的调试适配器, 一般来说就是 jtag 适配器了, 它会</description></item><item><title>PEAR 与 PECL 介绍</title><link>https://cifer97.github.io/posts/php-pear-pecl/</link><pubDate>Mon, 09 Feb 2015 09:39:30 +0000</pubDate><guid>https://cifer97.github.io/posts/php-pear-pecl/</guid><description>PEAR PEAR 全称是 PHP Extension and Application Repository, 和水果 &amp;ldquo;梨&amp;rdquo; 的英文发音是相同的. PEAR 存在的目的是: 提供一个有组织结构的开源代码仓库给 PHP 用户们 提供一个代码发布以及包维护的系统 制定一份 PHP 代码风格规范 (在这里: http://pear.php.net/manual/en/standards.php)</description></item><item><title>Pathinfo 和 Nginx</title><link>https://cifer97.github.io/posts/pathinfo-and-nginx/</link><pubDate>Fri, 30 Jan 2015 16:27:31 +0000</pubDate><guid>https://cifer97.github.io/posts/pathinfo-and-nginx/</guid><description>不知为何, Nginx 中配置 PATH_INFO 似乎一直以来是一件不那么明朗的事情, 在网上搜索的话, 会搜到各种各样的配置方式. 很多都是网友们自己 &amp;ldquo;发明&amp;rdquo; 的. 各大发行版安装好了 Nginx 之后, 默认也是没有配置对 PATH_INFO 的</description></item><item><title>Linux C 中如何正确的判断一个文件/目录文件是否存在</title><link>https://cifer97.github.io/posts/howto-detect-file-exists/</link><pubDate>Sun, 06 Apr 2014 14:59:00 +0000</pubDate><guid>https://cifer97.github.io/posts/howto-detect-file-exists/</guid><description>source: http://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c-cross-platform 其实不光是在 Linux 下编程, 在其他平台下我们都会有这样的需求: 我们要为应用程序创建自己的数据或者日志目录, 应用程序在每次启动时会检查文件系统中是否已经有了自己的目录, 没有的话就创建它, 有了的话就跳过这一</description></item><item><title>搞定 HP MicroServer 的 Smart Array Controller B120i 磁盘阵列, 在安装 RHEL 时</title><link>https://cifer97.github.io/posts/work-through-raid-in-rhel/</link><pubDate>Wed, 22 Jan 2014 09:48:00 +0000</pubDate><guid>https://cifer97.github.io/posts/work-through-raid-in-rhel/</guid><description>MicroServer Gen8 是 HP 服务器里较新的一个系列, 其所配备的磁盘阵列卡 &amp;mdash; Smart Array Controller B120i, 也是比较新的一种阵列卡, 目前 HP 仅提供了 RHEL, OpenSUSE, Microsoft 的驱动程序. 我们就是要在 MicroServer Gen8 上安装 RHEL6. MicroServer Gen8 的主板上的 ROM 上搭在了一个小型的配置系统, 叫做 Intelligence Provisioning, 在这里</description></item><item><title/><link>https://cifer97.github.io/eight-part-essay/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/eight-part-essay/</guid><description>Algorithms &amp;amp; Programming 二叉树 Z 字输出每层节点 - 2019 抖音
从有序单链表构造平衡二叉搜索树 - 2019 抖音
外部排序 - 2017 阿里
如何判断本机字节序 - 2017 滴滴
int i = 100;
char *p = &amp;amp;i;
打印 p[0],p[1],p[2],p[3]
提取 nginx log 中 url 访问 top20 - 2017 全民快乐
awk print &amp;ldquo;{$0}&amp;rdquo; | sort | uniq -c | sort | head -n 20
Singleton design - 2018 融 360, 腾讯视频
prevent construction (private constructor) thread safe 有序数组中找 target, 找不到返回 -1, 考虑数组元素全部相等的情况 - 2018 融 360
两个有序数组, 求交集, O(n) - 2018 融 360</description></item><item><title>Hall of Fame</title><link>https://cifer97.github.io/people/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/people/</guid><description>盛松成</description></item><item><title>书单</title><link>https://cifer97.github.io/reading/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/reading/</guid><description>常用资源 银行家杂志 Top 1000 World Bank 2021 聪明的投资者 - 格雷厄姆, 价值投资的鼻祖 一本书读懂财报 - 肖星, 非财务专业读者值得反复看几遍 穷查理宝典 - 查理·芒格智慧箴言录 - 彼得·考夫曼 伯克希尔年报 - 巴菲特 价值 - 张磊 资本回报</description></item><item><title>代码风格</title><link>https://cifer97.github.io/coding-style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/coding-style/</guid><description>以下几点关于 C 语言编程的风格是我一直贯彻执行的. 常用的逻辑功能写成宏 (如经常性地判断值是否合法, 省去众多冗长的 if) 今后的代码风格: 所有变量， 放在最前面声明， 而不是用到时再声明 (C89 风格) 变量名尽量短小精悍，</description></item><item><title>如何学习一个全新的领域</title><link>https://cifer97.github.io/how-to-learn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/how-to-learn/</guid><description>学习资源选择顺序: 领域专业人士的视频, 网课. 领域专业人士出的书 为什么视频在书前面, 因为视频的互动性和时效性相对强, 能给你更多前沿信息. 书籍更新迭代没有那么快里面的内容可能不会跟上时代前沿. 如何读书 我在</description></item><item><title>手把手教你读财报 2 - 18 节课看透银行业</title><link>https://cifer97.github.io/reading-notes/caibao2-bank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/reading-notes/caibao2-bank/</guid><description>如何分析银行股 可以参考国际上对银行评级的标准, 目前国际上比较成熟的银行监管体系是美国的 &amp;ldquo;骆驼评价体系&amp;rdquo;, 它是美国金融管理当局针对商业银行及其他金融机构的业务经营, 信用状况设计的</description></item><item><title>投资理念</title><link>https://cifer97.github.io/investingrule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/investingrule/</guid><description>如何选择企业 优先级从高到低: 不要选自己不了解的企业 选择尚未被高估的企业 PE/PB 选择财务稳健的企业 产生自由现金流的能力强, 负债低 选择盈利能力强的企业 ROA/ROE/ROIC 综合分析 选择有确定性1 的企业 选择持续支付股息的企业2 选择即</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SDN on</title><link>cifer76.github.io/tags/sdn/</link><description>Recent content in SDN on</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 25 Dec 2016 16:03:13 +0000</lastBuildDate><atom:link href="cifer76.github.io/tags/sdn/index.xml" rel="self" type="application/rss+xml"/><item><title>记一次 Indigo 与 Ryu 的连接建立问题</title><link>cifer76.github.io/posts/a-problem-ryu-indigo-conn-setup/</link><pubDate>Sun, 25 Dec 2016 16:03:13 +0000</pubDate><guid>cifer76.github.io/posts/a-problem-ryu-indigo-conn-setup/</guid><description>之前在研究 Indigo 和 Ryu 的衔接时碰到一个 OpenFlow 连接建立失败的问题, 特此记录下, 希望能够供别人参考.
在了解这个问题之前, 我们先回顾一下 OpenFlow 连接建立过程.
OpenFlow 协议的连接建立过程 根据 OpenFlow 协议标准的陈述我们能够知道, 交换机和控制器之间使用 TCP (或者 SSL) 传输协议, 交换机必须能够主动发起连接 (实际应用中, 连接一般都是都由交换机主动发起), 另外就是所有的 OpenFlow 消息, 都要用网络序 (大端序) 发送 (参见 OpenFlow Spec v1.3 以及 v1.4 的第 7 章)
TCP 连接的建立我们很熟悉了, 就是典型的三此握手过程. 在 TCP 连接建立以后, 交换机和控制器双方在 TCP 连接建立后需要立即发送给 OF_HELLO 消息给对方, 并且 OF_HELLO 必须是双发发送给对方的第一个消息, OF_HELLO 消息同时起到协商 OpenFlow 版本的功能.
当双方都收到了对方的 OF_HELLO 消息并且两边都共同支持一个最小版本, OpenFlow 连接就成功建立了, 接下来控制器就可以向交换机发送其它的消息, 比如一般第一次要发送的就是 OFPT_FEATURES_REQUEST 消息.
遇到的问题 在这部分工作中基于 Ryu 框架我写了个简单的 Ryu 小程序令它与 Indigo 通信, 但是发现似乎连接建立都不成功, 好在 indigo 项目的错误日志部分做的很好, 我打开了 verbose 级别的日志, 发现连接建立过程中 indigo 在收取 OF_HELLO 这个消息失败了, 结合代码发现是在读 socket 时发生了 EAGAIN (Resource temporary unvailable) 错误.</description></item><item><title>关于 OpenFlow 协议中 Instruction, Action 概念的解读</title><link>cifer76.github.io/posts/openflow-instruction-action/</link><pubDate>Mon, 03 Oct 2016 21:45:30 +0000</pubDate><guid>cifer76.github.io/posts/openflow-instruction-action/</guid><description>(首发于 sdnlab: http://www.sdnlab.com/17952.html)
阅读任何一个协议都要注意的一点是这个协议中所定义的专有术语, 对这些术语的理解不到位的话也会造成对协议的理解偏差. 本文想和大家分享几个可能容易混淆的术语.
在 OpenFlow 协议文档中经常会看到这么几个词语: Instruction, Action, Apply-actions, Action Set, Action List, Clear-actions, &amp;hellip; 有点迷惑人, 实际上这里面只有两个实体的概念: Instruction 和 Action. 为了保持后文的易读性, 这两个概念分别用中文 &amp;ldquo;指令&amp;rdquo; 和 &amp;ldquo;动作&amp;rdquo; 来描述. 下文中的 &amp;ldquo;指令&amp;rdquo; 和 &amp;ldquo;动作&amp;rdquo; 都特指在 OpenFlow 协议中的含义.
指令这个词, 特指流表表项中的指令, 当某个报文匹配了这个表项之后, 表项中的指令就会被应用于这个报文; 而动作是比指令更细粒度的概念, 但它并不是局限于流表表项的概念, 动作可以独立于指令而存在, 也可以被包含在指令中, 具体说来, 我们在下流表的时候, 可以为某个表项的某种指令指定一些列的动作, 但是动作并不是只有下流表的时候才会被用到.
本文以目前较新的 Openflow 1.4 版本为准, 来分别看一下指令和动作的含义.
指令 每一个流表的表项都包含一系列的指令, 当报文匹配上了这个表项后, 这些指令就会被执行, 这些指令的执行结果有几种: 改变报文, 改变 action set, 改变 pipeline. 这些指令可以按照其执行结果的不同而分类, 不同的流表的表项包含的指令种类也不同, 前面说了指令可以包含动作, 但也并非所有种类的指令都包含动作, 下面我们一起来看一下指令的分类.
指令的分类 OpenFlow 1.</description></item></channel></rss>
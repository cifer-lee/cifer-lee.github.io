<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SDN on</title><link>https://cifer76.github.io/tags/sdn/</link><description>Recent content in SDN on</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 31 Dec 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer76.github.io/tags/sdn/index.xml" rel="self" type="application/rss+xml"/><item><title>LoxiGen 与 Indigo 项目介绍</title><link>https://cifer76.github.io/posts/indigo-loxigen/</link><pubDate>Sat, 31 Dec 2016 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/indigo-loxigen/</guid><description>Indigo 是由 Big Switch 开发, 现在托管在 Floodlight 组织下的 OpenFlow agent 开源实现. OpenFlow 控制器的开源实现有很多, 像是 Ryu, ODL, POX 等等, 但是 agent 方面的开源实现可能相对少一些, Indigo 是一个非常精巧的实现, 但是似乎网上 SDN 相关的中文社区对其介绍的文档却很少, 本文将对 Indigo 及其所依附的 LoxiGen 项目做一个简单的介绍.
关于 LOXI 与 Loxigen LOXI (Logical OpenFlow eXtensible Interface), 是一种描述 OpenFlow 协议的逻辑语言.
LoxiGen 项目能够解读 LOXI 语言, 进而用来生成各种编程语言的 OpenFlow 协议库. 所以说 LoxiGen 实际上是一个 “编译器” 项目, 可想而知 LoxiGen 包含一个前端用来解析 LOXI 语言, 以及包含各种编程语言的后端来生成这些编程语言的代码. 目前包含 Java, Python 以及 C 语言的后端, 生成的 C 版本的协议库叫做 LOCI, Java 版本的叫做 OpenFlowJ, Python 版本的叫做 pyloxi.</description></item><item><title>记一次 Indigo 与 Ryu 的连接建立问题</title><link>https://cifer76.github.io/posts/a-problem-ryu-indigo-conn-setup/</link><pubDate>Sun, 25 Dec 2016 16:03:13 +0000</pubDate><guid>https://cifer76.github.io/posts/a-problem-ryu-indigo-conn-setup/</guid><description>之前在研究 Indigo 和 Ryu 的衔接时碰到一个 OpenFlow 连接建立失败的问题, 特此记录下, 希望能够供别人参考.
在了解这个问题之前, 我们先回顾一下 OpenFlow 连接建立过程.
OpenFlow 协议的连接建立过程 根据 OpenFlow 协议标准的陈述我们能够知道, 交换机和控制器之间使用 TCP (或者 SSL) 传输协议, 交换机必须能够主动发起连接 (实际应用中, 连接一般都是都由交换机主动发起), 另外就是所有的 OpenFlow 消息, 都要用网络序 (大端序) 发送 (参见 OpenFlow Spec v1.3 以及 v1.4 的第 7 章)
TCP 连接的建立我们很熟悉了, 就是典型的三此握手过程. 在 TCP 连接建立以后, 交换机和控制器双方在 TCP 连接建立后需要立即发送给 OF_HELLO 消息给对方, 并且 OF_HELLO 必须是双发发送给对方的第一个消息, OF_HELLO 消息同时起到协商 OpenFlow 版本的功能.
当双方都收到了对方的 OF_HELLO 消息并且两边都共同支持一个最小版本, OpenFlow 连接就成功建立了, 接下来控制器就可以向交换机发送其它的消息, 比如一般第一次要发送的就是 OFPT_FEATURES_REQUEST 消息.
遇到的问题 在这部分工作中基于 Ryu 框架我写了个简单的 Ryu 小程序令它与 Indigo 通信, 但是发现似乎连接建立都不成功, 好在 indigo 项目的错误日志部分做的很好, 我打开了 verbose 级别的日志, 发现连接建立过程中 indigo 在收取 OF_HELLO 这个消息失败了, 结合代码发现是在读 socket 时发生了 EAGAIN (Resource temporary unvailable) 错误.</description></item><item><title>OpenFlow 协议匹配结构进化与 OXM TLV 解读</title><link>https://cifer76.github.io/posts/openflow-oxm-tlv/</link><pubDate>Mon, 14 Nov 2016 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/openflow-oxm-tlv/</guid><description>在 OpenFlow 流表定义中, 报文匹配表项是个重要的行为, 我们下发的每一个流表表项都可以包含一到多个匹配项, 报文进来时会与这些匹配项比较, 如果匹配成功的话, 表项中动作也相应的被附加到报文上. 典型的匹配项有入端口, 源 MAC 地址, 目的 MAC 地址, VLAN Id, 源 IP 地址, 目的 IP 地址, MPLS 标签等等. 不难想象, 网络中的报文种类繁杂, 想要能够匹配每一种报文, 光匹配项就能列一个长长的列表出来, 并且随着各种网络通信协议的不断演进以及越来越复杂的网络业务, 这些匹配项将来还会可能还会增加. 所以在 OpenFlow 协议中, 选择一种合适的数据结构来描述这些匹配项就显得重要起来.
早期的匹配结构 在 OpenFlow 协议早期的版本中, 使用一种固定的数据结构来表述所有的匹配项, 这个数据结构长度固定并且所有的匹配项都包含在里面:
enum ofp_match_type { OFPMT_STANDARD, /* The match fields defined in the ofp_match structure apply */ }; /* Fields to match against flows */ struct ofp_match { uint16_t type; /* One of OFPMT_* */ uint16_t length; /* Length of ofp_match */ uint32_t in_port; /* Input switch port.</description></item><item><title>关于 OpenFlow 协议中 Instruction, Action 概念的解读</title><link>https://cifer76.github.io/posts/openflow-instruction-action/</link><pubDate>Mon, 03 Oct 2016 21:45:30 +0000</pubDate><guid>https://cifer76.github.io/posts/openflow-instruction-action/</guid><description>(首发于 sdnlab: http://www.sdnlab.com/17952.html)
阅读任何一个协议都要注意的一点是这个协议中所定义的专有术语, 对这些术语的理解不到位的话也会造成对协议的理解偏差. 本文想和大家分享几个可能容易混淆的术语.
在 OpenFlow 协议文档中经常会看到这么几个词语: Instruction, Action, Apply-actions, Action Set, Action List, Clear-actions, &amp;hellip; 有点迷惑人, 实际上这里面只有两个实体的概念: Instruction 和 Action. 为了保持后文的易读性, 这两个概念分别用中文 &amp;ldquo;指令&amp;rdquo; 和 &amp;ldquo;动作&amp;rdquo; 来描述. 下文中的 &amp;ldquo;指令&amp;rdquo; 和 &amp;ldquo;动作&amp;rdquo; 都特指在 OpenFlow 协议中的含义.
指令这个词, 特指流表表项中的指令, 当某个报文匹配了这个表项之后, 表项中的指令就会被应用于这个报文; 而动作是比指令更细粒度的概念, 但它并不是局限于流表表项的概念, 动作可以独立于指令而存在, 也可以被包含在指令中, 具体说来, 我们在下流表的时候, 可以为某个表项的某种指令指定一些列的动作, 但是动作并不是只有下流表的时候才会被用到.
本文以目前较新的 Openflow 1.4 版本为准, 来分别看一下指令和动作的含义.
指令 每一个流表的表项都包含一系列的指令, 当报文匹配上了这个表项后, 这些指令就会被执行, 这些指令的执行结果有几种: 改变报文, 改变 action set, 改变 pipeline. 这些指令可以按照其执行结果的不同而分类, 不同的流表的表项包含的指令种类也不同, 前面说了指令可以包含动作, 但也并非所有种类的指令都包含动作, 下面我们一起来看一下指令的分类.
指令的分类 OpenFlow 1.</description></item></channel></rss>
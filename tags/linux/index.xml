<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on</title><link>https://cifer76.github.io/tags/linux/</link><description>Recent content in linux on</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 06 May 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer76.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>挂载 (mount) 深入理解</title><link>https://cifer76.github.io/posts/mount-illustration/</link><pubDate>Tue, 06 May 2014 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/mount-illustration/</guid><description>首先引用一句 wiki 上的定义来开篇:
Mounting takes place before a computer can use any kind of storage device (such as a hard drive, CD-ROM, or network share). The user or their operating system must make it accessible through the computer&amp;rsquo;s file system. A user can only access files on mounted media.
意思是说, &amp;ldquo;挂载&amp;rdquo; 发生在计算机想要使用任何类型的存储设备 (如硬盘, CD-ROM, 网络设备) 之前. 操作系统必须将这个设备纳入自己的文件系统中去.
要注意的是, 这里的存储设备不一定必须是外部的存储设备, 也可以是你安装系统的硬盘上的分区.
例子先 光看上面说的还不够, 先看个例子吧, 这个例子摘自 man mount, 在 man 手册中这个例子下的一句话非常好的解释了 mount 到底是什么.</description></item><item><title>Linux C 中如何正确的判断一个文件/目录文件是否存在</title><link>https://cifer76.github.io/posts/howto-detect-file-exists/</link><pubDate>Sun, 06 Apr 2014 14:59:00 +0000</pubDate><guid>https://cifer76.github.io/posts/howto-detect-file-exists/</guid><description>source: http://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c-cross-platform
其实不光是在 Linux 下编程, 在其他平台下我们都会有这样的需求: 我们要为应用程序创建自己的数据或者日志目录, 应用程序在每次启动时会检查文件系统中是否已经有了自己的目录, 没有的话就创建它, 有了的话就跳过这一步. 那么如何去判断文件系统中是否已经存在了要创建的目录呢?
Linux 或者 GNU C 都没有提供一个像 file_exists() 这样直观的系统调用给我们, 所以我们得通过其它的调用来达成这个目标.
实际上当我第一次要解决这个问题时, 我先 google 了一下, 这个问题在 stackoverflow 上有人问过而且非常受欢迎, 很多人对这个问题又点赞又收藏的, 自然, 这个问题也收到了不少好的答案, 这篇文章算是对这些好答案的总结和延伸.
我们先来看一个大家都应该知道的方式, 第一种方式:
fopen() fopen() 方法是流阶级的方法, 这个方法接收用户提供的文件名, 以及访问方式, 然后尝试着打开文件, 打开成功则返回 handle, 失败则返回 NULL. 因此有人提出了使用这个方法来判断指定的文件是否存在的方案:
#include &amp;lt;stdio.h&amp;gt; ... FILE *fp = NULL; fp = fopen(&amp;quot;/tmp/test/somefile&amp;quot;, &amp;quot;r&amp;quot;); if(fp) { // exists } else { // not exists } fclose(fp); 这也是 stackoverflow 上唯一一个得负分的答案, 这个方案的问题在于它没有考虑到文件权限的问题, 而 fopen() 这个函数又是如此的简单 &amp;mdash; 不管因为什么原因打开文件失败了, 它只是返回 NULL 给你, 不会提供更多的错误信息.</description></item><item><title>GNU Screen Tutorial</title><link>https://cifer76.github.io/posts/gnu-screen-tutorial/</link><pubDate>Mon, 13 Jan 2014 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/gnu-screen-tutorial/</guid><description>概念 会话, screen 有自己的会话的概念, 当你运行 screen 命令后, 你就启动了一个 &amp;ldquo;会话&amp;rdquo;. 下文中的&amp;quot;会话&amp;quot;都是指 screen 会话. 窗口, 每一个会话可以包含一至多个窗口, 在每一个窗口中, 你可以做单独的工作. 比如说在窗口1 中开着 vim 写作, 在窗口2 中运行 netstat 监控网络, 而第三个窗口保持 bash shell 不做其他的事 默认情况下, 当你运行 screen 之后, screen 将为你建立一个会话, 并且为你建立一个默认的窗口, 并且, 为你在这个窗口中运行 bash shell.
优点 使用 screen 的优点是很多的, 尤其是你需要 ssh 登录到远程主机进行工作的时候, screen 可以帮助你使你即使从远程主机退出了, 你的工作也能够继续, 这是其一, 另一点就是它可以帮你&amp;quot;节省终端&amp;quot; - 当你需要登录远程做多个工作的时候, 你不必开多个终端分别 ssh 登录远程, 然后分别做各自的工作. 这在 多个窗口 这一节会分析.
运行 screen 只需要简单的执行 screen 命令:
$ screen 一般来说, 你会看到一屏关于 screen 程序的介绍和版权信息, 根据按空格或回车就能跳过.</description></item></channel></rss>
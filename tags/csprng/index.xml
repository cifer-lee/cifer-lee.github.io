<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CSPRNG on</title><link>https://cifer76.github.io/tags/csprng/</link><description>Recent content in CSPRNG on</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 10 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer76.github.io/tags/csprng/index.xml" rel="self" type="application/rss+xml"/><item><title>CSPRNG 如何做到不可预测</title><link>https://cifer76.github.io/posts/csprng/</link><pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/csprng/</guid><description>上一篇文章 我们提到了实现伪随机数生成器 PRNG 的一种经典算法: 线性同余法. 我们也提到了线性同余法由于无法做到不可预测而不能成为密码学安全的算法, 如果对其加以改进使做到不可预测，我们就能够得到密码学安全的随机数生成器 CSPRNG. 本文我们就来看看线性同余法是如何被预测的以及 CSPRNG 是如何克服这一点的.
线性同余为什么是可预测的 线性同余的公示如下, A, C, M 是常数:
$$R_{n+1} = (A \times R_n + C) \bmod M$$1
其中
$$R_0 = (A \times seed + C) \bmod M$$
我们说过不可预测的定义:
即使给出产生序列的算法或硬件和所有以前产生的位序列, 也不可能通过计算来预测下一个随机位是什么.
应用密码学: 协议, 算法与 C 源程序》第 2 版2
线性同余的算法很简单只是一个多项式, 其常数 A, C, M 一般是不公开的, seed 一般也不会让我们知道, 但是显然我们只要知道它生成的 4 个随机数, 就能反推出 A, C, M 以及 seed, 从而整个随机序列我们都能知晓.
CSPRNG 如何做到不可预测 由上述可知线性同余的问题在于容易被反推, 所以首先我们要解决容易反推的问题, 如果做到不被反推呢?</description></item></channel></rss>
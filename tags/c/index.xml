<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on</title><link>https://cifer76.github.io/tags/c/</link><description>Recent content in C on</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 23 Feb 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer76.github.io/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>如何在应用层控制最大客户端连接</title><link>https://cifer76.github.io/posts/controlling-client-connections/</link><pubDate>Fri, 23 Feb 2018 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/controlling-client-connections/</guid><description>当有客户端连接, 而程序中没有去处理时, select 就回持续不断的返回这个文件描述符可写, 例如, 下面是我以前写的一段有 bug 的程序:
int csocks[MAX_CONNECTION]; memset(csocks, -1, MAX_CONNECTION * sizeof(int)); FD_SET(sock, &amp;amp;rset); while(1) { if (select(FD_SETSIZE, &amp;amp;rset, NULL, NULL, NULL) &amp;lt;= 0) { return ; } if (FD_ISSET(sock, &amp;amp;rset)) { // looking for an unused socket for (int i = 0 ; i &amp;lt; MAX_CONNECTION; ++i) { if((-1 == csocks[i]) &amp;amp;&amp;amp; (-1 != (csocks[i] = accept(sock, NULL, NULL)))) break; } } } 这段程序里, sock 是一个侦听套接字, 负责侦听客户端的连接, 一有连接就会去调用 accept 来接受客户端的连接 &amp;mdash; 当然, 这是有条件的, 那就是能够接收的最大的客户端数量是 MAX_CONNECTION, 由上面的程序里可以看到, 当连接的客户端的数量已经超过了 MAX_CONNECTION 时, 将不会再接受任何连接.</description></item><item><title>C 语言宏的展开与字符串化宏和符号连接宏</title><link>https://cifer76.github.io/posts/c-macro/</link><pubDate>Tue, 20 Feb 2018 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/c-macro/</guid><description>C 语言由于没什么高级的特性, 所以现有的特性被玩的各种精. 宏展开就是很值得品味的部分.
递归展开问题 宏定义语句是这样的:
#define identifier token-sequence
在具体的宏展开过程中, 遇到标识符时, 此标识符会整个的被使用 token-sequence 展开, 如果 token-sequence 中还包含有其他的被定义的宏标识符, 也都会相应的被展开. 但是显然, 已经展开过的标识符如果再次出现, 则维持原样不变, 不会再次展开, 否则就递归个没完了.
比如说有如下代码段:
#define x y #define y x x 对其执行 gcc -E 预处理时得到的结果是 x, 这里发生了两步替换, 首先 x 被展开成 y, 然后因为 y 也被定义为宏, y 又展开成 x. 注意此时, 由于 x 这个标识符已经展开过, 这里是第二次出现, 所以不会被再次展开成 y. 不然就没完没了了.
这部分可以参见 K&amp;amp;R C, A.12 中有这么一段话:
In both kinds of macro, the replacement token sequence is repeatedly rescanned for more defined identifiers.</description></item><item><title>Linux C 中如何正确的判断一个文件/目录文件是否存在</title><link>https://cifer76.github.io/posts/howto-detect-file-exists/</link><pubDate>Sun, 06 Apr 2014 14:59:00 +0000</pubDate><guid>https://cifer76.github.io/posts/howto-detect-file-exists/</guid><description>source: http://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c-cross-platform
其实不光是在 Linux 下编程, 在其他平台下我们都会有这样的需求: 我们要为应用程序创建自己的数据或者日志目录, 应用程序在每次启动时会检查文件系统中是否已经有了自己的目录, 没有的话就创建它, 有了的话就跳过这一步. 那么如何去判断文件系统中是否已经存在了要创建的目录呢?
Linux 或者 GNU C 都没有提供一个像 file_exists() 这样直观的系统调用给我们, 所以我们得通过其它的调用来达成这个目标.
实际上当我第一次要解决这个问题时, 我先 google 了一下, 这个问题在 stackoverflow 上有人问过而且非常受欢迎, 很多人对这个问题又点赞又收藏的, 自然, 这个问题也收到了不少好的答案, 这篇文章算是对这些好答案的总结和延伸.
我们先来看一个大家都应该知道的方式, 第一种方式:
fopen() fopen() 方法是流阶级的方法, 这个方法接收用户提供的文件名, 以及访问方式, 然后尝试着打开文件, 打开成功则返回 handle, 失败则返回 NULL. 因此有人提出了使用这个方法来判断指定的文件是否存在的方案:
#include &amp;lt;stdio.h&amp;gt; ... FILE *fp = NULL; fp = fopen(&amp;quot;/tmp/test/somefile&amp;quot;, &amp;quot;r&amp;quot;); if(fp) { // exists } else { // not exists } fclose(fp); 这也是 stackoverflow 上唯一一个得负分的答案, 这个方案的问题在于它没有考虑到文件权限的问题, 而 fopen() 这个函数又是如此的简单 &amp;mdash; 不管因为什么原因打开文件失败了, 它只是返回 NULL 给你, 不会提供更多的错误信息.</description></item></channel></rss>
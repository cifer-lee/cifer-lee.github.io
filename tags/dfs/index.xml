<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DFS on 狂想曲</title><link>/tags/dfs/</link><description>Recent content in DFS on 狂想曲</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 22 Oct 2016 17:24:36 +0000</lastBuildDate><atom:link href="/tags/dfs/index.xml" rel="self" type="application/rss+xml"/><item><title>二叉树递归遍历的本质以及用迭代遍历精确模拟递归遍历</title><link>/posts/binary-tree-traversal/</link><pubDate>Sat, 22 Oct 2016 17:24:36 +0000</pubDate><guid>/posts/binary-tree-traversal/</guid><description>递归遍历是实现深度优先遍历的既直观又简单的方式, 二叉树递归遍历的本质其实就是在不断的压栈与出栈, 明白了这一道理之后就很容易借助栈结构来将递归遍历转换成迭代遍历.
void traverse(struct TreeNode *root) { if (root) { /* 1 */ traverse(root-&amp;gt;left); /* 2 */ traverse(root-&amp;gt;right); /* 3 */ } } 上面的 1, 2, 3 三个位置是节点访问可能发生的位置, 分别为先序, 中序, 后序遍历. 下面我们不考虑对节点数据的访问, 单独分析一下递归遍历过程的细节.
函数调用与递归的本质 要分析递归遍历的细节, 我们就要知道递归的过程中发生了什么, 而递归实际上也只是函数调用的一种, 所以我们需要先来看一下函数调用的过程中发生了什么.
当函数调用发生时, 传给该函数的参数, 以及被调函数内部的局部变量都会被压入栈中 (现在的处理器和编译器基本都支持通过寄存器传参, 这里我们没必要考虑这些个情况), 而在被调函数返回时, 这些信息又都会从栈中弹出. 递归只是一种自己调用自己的函数调用, 也是符合这个规则的.
我们以上面的 traverse(struct TreeNode *root) 方法和下面的一颗二叉树为例, 观察一下递归遍历过程中的栈变化.
A / \ B C / \ / \ D E F G 其中 A 是根节点, 遍历过程由 traverse(root) 被调用开始, 那么按照上述的规则, 会发生如下几步, 为方便起见, 栈的增长为从左往右:</description></item></channel></rss>
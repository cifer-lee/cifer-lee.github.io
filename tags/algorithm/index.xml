<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on</title><link>https://cifer76.github.io/tags/algorithm/</link><description>Recent content in algorithm on</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 05 Jan 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer76.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>嵌入式哈系表的实现</title><link>https://cifer76.github.io/posts/embedded-hashtable-implementation/</link><pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/embedded-hashtable-implementation/</guid><description>这篇文章是一个例子, 重点在于阐述嵌入式哈系表结构, 而不是针对不同键类型进行哈希的方法.
关于哈希冲突的解决, 我们使用链表存储冲突的节点, 这在一些书里被称为 &amp;ldquo;Separate Chaning&amp;rdquo; 方法.
由于在链表中插入以及删除节点需要更新节点的前继和后继的指针, 所以为了方便的从链表中插入以及删除节点, hlist_node_t 结构中定义两个指针, 分别指向前继和后继.
typedef struct hlist_node_s { struct hlist_node_s *prev; struct hlist_node_s *next; } hlist_node_t; hlist_t 结构中的 heads 是一个数组, 每个数组元素都只是一个头节点, 头节点不会嵌入到别的结构体中.
typedef struct xhash { hlist_node_t *heads; int size; } xhash_t; void hlist_node_init(hlist_node_t *node) { node-&amp;gt;next = node-&amp;gt;prev = node; } xhash_t *xhash_create(int size) { xhash_t *hash; int i; /* TODO Get next prime bigger than *size* */ /* size = next_prime(size);*/ hash = calloc(1, sizeof *hash); if (!</description></item><item><title>二叉树递归遍历的本质以及用迭代遍历精确模拟递归遍历</title><link>https://cifer76.github.io/posts/binary-tree-traversal/</link><pubDate>Sat, 22 Oct 2016 17:24:36 +0000</pubDate><guid>https://cifer76.github.io/posts/binary-tree-traversal/</guid><description>递归遍历是实现深度优先遍历的既直观又简单的方式, 二叉树递归遍历的本质其实就是在不断的压栈与出栈, 明白了这一道理之后就很容易借助栈结构来将递归遍历转换成迭代遍历.
void traverse(struct TreeNode *root) { if (root) { /* 1 */ traverse(root-&amp;gt;left); /* 2 */ traverse(root-&amp;gt;right); /* 3 */ } } 上面的 1, 2, 3 三个位置是节点访问可能发生的位置, 分别为先序, 中序, 后序遍历. 下面我们不考虑对节点数据的访问, 单独分析一下递归遍历过程的细节.
函数调用与递归的本质 要分析递归遍历的细节, 我们就要知道递归的过程中发生了什么, 而递归实际上也只是函数调用的一种, 所以我们需要先来看一下函数调用的过程中发生了什么.
当函数调用发生时, 传给该函数的参数, 以及被调函数内部的局部变量都会被压入栈中 (现在的处理器和编译器基本都支持通过寄存器传参, 这里我们没必要考虑这些个情况), 而在被调函数返回时, 这些信息又都会从栈中弹出. 递归只是一种自己调用自己的函数调用, 也是符合这个规则的.
我们以上面的 traverse(struct TreeNode *root) 方法和下面的一颗二叉树为例, 观察一下递归遍历过程中的栈变化.
A / \ B C / \ / \ D E F G 其中 A 是根节点, 遍历过程由 traverse(root) 被调用开始, 那么按照上述的规则, 会发生如下几步, 为方便起见, 栈的增长为从左往右:</description></item><item><title>对快速排序的理解与实现</title><link>https://cifer76.github.io/posts/quick-sort/</link><pubDate>Sun, 24 Jul 2016 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/quick-sort/</guid><description>快速排序的思想 选出一个 pivot, 比 pivot 小的全都换到左边, 比 pivot 大的全都换到右边, 最后安置好 pivot. 然后以此 pivot 位置为分界线, 对两个区间递归执行快速排序, 当最终每个区间大小为 1 的时候, 排序也就完成了.
要实践这个思想, 需要解决几个问题:
pivot 的选取策略 交换策略, 也就是分区策略 pivot 的最终位置确定 关于 pivot 的选取, 原则是尽量是整个数组中所有的元素中位数. 这是个矛盾的问题, 我们找的 pivot 越接近中位数, 快排效率自然越高, 但是我们花费在找 pivot 上的时间也越长. 快排算法的核心还是要放在分治本身, 不必对 pivot 的要求过于苛刻.
目前公认比较不错的 pivot 选取策略叫做 &amp;ldquo;Median-of-Three&amp;rdquo;, 顾名思义, 它的意思就是在整个数组中选取三个元素, 然后再选出这三个元素的中位数作为 pivot. 那么选择哪个元素呢? 就是第一, 最后, 和中间.
第二个问题, 交换. 交换这个过程在快排里有个专门的术语叫做 &amp;ldquo;Partition&amp;rdquo;, 也就是分区. 因为快排的核心其实就是在不断的分区, 将 &amp;lt; pivot 的分一区, &amp;gt; pivot 的分另一区, 当分区结束后, 所有 &amp;lt; pivot 的都在 pivot 左边, 反之都在 pivot 右边.</description></item></channel></rss>
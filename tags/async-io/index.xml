<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>async io on</title><link>cifer76.github.io/tags/async-io/</link><description>Recent content in async io on</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 06 Nov 2017 00:00:00 +0000</lastBuildDate><atom:link href="cifer76.github.io/tags/async-io/index.xml" rel="self" type="application/rss+xml"/><item><title>深入解读同步/异步 IO 编程模型</title><link>cifer76.github.io/posts/io-programming/</link><pubDate>Mon, 06 Nov 2017 00:00:00 +0000</pubDate><guid>cifer76.github.io/posts/io-programming/</guid><description>所谓 &amp;ldquo;同步&amp;rdquo; 和 &amp;ldquo;异步&amp;rdquo; 是从调用者的角度来说的. 如果调用者不得不等待 IO 完成才能执行后续的工作, 那就是同步; 否则, 就是异步. 这是我对 &amp;ldquo;同步&amp;rdquo; 和 &amp;ldquo;异步&amp;rdquo; 的定义, 这个定义清晰精炼, 巧妙的帮我们把 &amp;ldquo;理解什么叫做异步&amp;rdquo; 这项工作简化成了 &amp;ldquo;理解什么叫做 IO 完成&amp;rdquo;.
在 *nix 系统中, IO 操作分为两个阶段. 第一阶段是从用户空间发起请求到数据真正就绪的等待阶段, 第二阶段是数据就绪后从用户空间或者内核空间拷贝给对方的数据拷贝阶段. 只有这两个阶段都完成了, 才叫做 &amp;ldquo;IO 完成&amp;rdquo;.
如果看过圣书 Unix Network Programming Volume 1 , 就知道 Richard 介绍了 5 种 IO 模型, 下面我们按照上面的定义给这 5 中模型分个类.
Blocking IO 这个模型是最简单的, 程序流调用 read/writei, 如果运气好正好有数据, 就进行 IO 第二阶段, 否则就卡在第一阶段等数据就绪. 当第二阶段结束 read/write 返回后, 继续执行后面的程序.
/* processing work A */ read(fd, buf, size); /* blocked here */ /* continue processing work B */ 显然这个模型是同步的, 程序流必须等 IO 两个阶段都完成了, 才能得以执行后续的工作.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>php on</title><link>/tags/php/</link><description>Recent content in php on</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 09 Feb 2015 09:39:30 +0000</lastBuildDate><atom:link href="/tags/php/index.xml" rel="self" type="application/rss+xml"/><item><title>PEAR 与 PECL 介绍</title><link>/posts/php-pear-pecl/</link><pubDate>Mon, 09 Feb 2015 09:39:30 +0000</pubDate><guid>/posts/php-pear-pecl/</guid><description>PEAR PEAR 全称是 PHP Extension and Application Repository, 和水果 &amp;ldquo;梨&amp;rdquo; 的英文发音是相同的. PEAR 存在的目的是:
提供一个有组织结构的开源代码仓库给 PHP 用户们 提供一个代码发布以及包维护的系统 制定一份 PHP 代码风格规范 (在这里: http://pear.php.net/manual/en/standards.php) 运作 PHP Extension Community Lbrary (PECL) 姐妹组织 维护相关的网站, 邮件列表, 源镜像, PEAR/PECL 社区 PEAR 是一个社区驱动的组织, 由开发者管理. PEAR 的使命 PEAR 的使命就是为 PHP 用户提供良好可重用的组件 (避免让用户自造轮子), 以及领导 PHP 革新, 努力为 PHP 开发者提供最佳的开发体验.
由 PHP 书写的结构良好的代码库以及应用 PEAR 中的代码以 &amp;ldquo;包&amp;rdquo; 为单元. 每一个包都是一个独立维护的项目, 有专门的开发团队, 有自己的版本号, 发布周期, 项目文档, 以及与其他包的依赖关系信息.
PEAR 中的包都是以 gzip tar 档案格式发布的. 在你的系统上, 你可以使用 &amp;ldquo;PEAR installer&amp;rdquo; (http://pear.</description></item><item><title>Pathinfo 和 Nginx</title><link>/posts/pathinfo-and-nginx/</link><pubDate>Fri, 30 Jan 2015 16:27:31 +0000</pubDate><guid>/posts/pathinfo-and-nginx/</guid><description>不知为何, Nginx 中配置 PATH_INFO 似乎一直以来是一件不那么明朗的事情, 在网上搜索的话, 会搜到各种各样的配置方式. 很多都是网友们自己 &amp;ldquo;发明&amp;rdquo; 的. 各大发行版安装好了 Nginx 之后, 默认也是没有配置对 PATH_INFO 的支持的, 怎么会这样呢? 难道 Nginx 就没有一个官方的解决方案吗?
自然是有的.
PATH_INFO 是 CGI 1.1 标准中规定的一个变量, 在 www 服务器委托 CGI 脚本执行任务时, 需要传递给 CGI 脚本的信息. 这么重要的一个变量, Nginx 当然是会支持的. 参考一中就是官方的方案. 我们在这里重复一下.
首先我们知道, 在 nginx 中, 是可以使用 nginx 自带的一些命令, 给 CGI 1.1 中规定的那些变量赋值的, 而这些命令默认都位于 /etc/nginx/fastcgi.conf 或者 /etc/nginx/fastcgi_params 文件里, 在配置 fastcgi 程序处理我们的请求时, 只要在 nginx 中包含这个两个文件之一, fastcgi 程序就能够取得所需要的变量. 在我的系统上, /etc/nginx/fastcgi.conf 文件是这样的:
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_param REQUEST_URI $request_uri; fastcgi_param DOCUMENT_URI $document_uri; fastcgi_param DOCUMENT_ROOT $document_root; fastcgi_param SERVER_PROTOCOL $server_protocol; fastcgi_param HTTPS $https if_not_empty; fastcgi_param GATEWAY_INTERFACE CGI/1.</description></item><item><title>通俗地解释 CGI, FastCGI, php-fpm 之间的关系</title><link>/posts/cgi-fastcgi-php-fpm/</link><pubDate>Wed, 02 Jul 2014 00:00:00 +0000</pubDate><guid>/posts/cgi-fastcgi-php-fpm/</guid><description>这要了解一点万维网 (WWW) 的历史, 才能更好地了解个中关系.
早期的网站基本都是静态的, 那时候的 web server 几乎所有工作就是给访问者提供静态资源, 网站与访问者之间缺乏交互. 后来随着 WWW 的发展网站变得交互性强了起来, 交互性强了也意味着 web server 端的业务逻辑复杂了起来, 不再是简单地解析 url, 定位并返回用户请求的资源, 而是要处理很多用户请求的动态资源以及许多复杂的业务, 这些工作都交给 web server 来做是不现实的, 因为单纯作为 web server 是不知道也不应该关注业务的.
于是 CGI 出现了, 它使得 web server 可以把复杂的业务逻辑交给 cgi 脚本程序来做, CGI 协议定义了 web server 与 cgi 程序之间通信的 context, web server 一收到动态资源的请求就 fork 一个子进程调用 cgi 程序处理这个请求, 同时将和此请求相关的 context 传给 cgi 程序, 像是 path_info, script path, request method, remote ip 等等&amp;hellip;
但是显然每次来个请求 web server 就去 fork 子进程是很低效的, 在网站访问量逐渐增大时网站性能问题日益凸显.</description></item></channel></rss>
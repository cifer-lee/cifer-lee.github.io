<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web on</title><link>https://cifer76.github.io/categories/web/</link><description>Recent content in Web on</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 24 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer76.github.io/categories/web/index.xml" rel="self" type="application/rss+xml"/><item><title>A Clarification About the Same-Origin Policy</title><link>https://cifer76.github.io/posts/same-origin-policy/</link><pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/same-origin-policy/</guid><description>转自我在 Stackoverflow 的回答:
I finally made myself clear after having been struggling half a hour about this saying:
Cross-origin writes are typically allowed&amp;hellip;.
Cross-origin embedding is typically allowed&amp;hellip;.
Cross-origin reads are typically not allowed&amp;hellip;
To better understand with these three phrases, the first thing you need to keep in mind is that same-origin policy is about restricting access the loaded result from one origin to another origin, within your browser, so it does nothing directly to do with cross-origin requesting, which involves requesting to the server.</description></item><item><title>浏览器追踪技术与防范</title><link>https://cifer76.github.io/posts/browser-tracking/</link><pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/browser-tracking/</guid><description>Cookie 这里说的就是我们通常所熟知的 cookie，很多第三方公司就是借助这种 cookie 实现追踪的。比如网站 A，B 都使用了 DoubleClick 的 js 脚本，DoubleClick 的脚本在用户访问网站 A 时被加载并埋下 cookie，下次用户访问网站 B 时这个信息会上报回给 DoubleClick。这种方式实现起来简单，防范也简单，定期清理 cookie 就能定期的中断跟踪，或者我们也可以直接禁止第三方 cookie 就好了，不过这样一来一些非跟踪的第三方服务比如 google analytics/adsense 也会被误杀。
Supercookie Supercookie 应该是一个统称，不同于普通的 cookie，supercookie 通过各种奇技淫巧达到让用户难以清除甚至无法清除的目地。比如利用 flash 插件存储 cookie 数据，这样一来 cookie 数据就存放于 flash 插件的存储区，而浏览器一般是没有提供插件数据清理功能的，这就阻拦了大部分用户清理 cookie；另外还有一种方式叫做 Image hack，它利用了浏览器默认会缓存图片的行为，给你生成一张 100 像素的每个像素的颜色对你也是固定的小图片，以此来标记你，当浏览器下次发出请求时，一段简单的 js 代码就能够读出缓存中这张图片的像素颜色特征。
这两种方式可算是奇淫，但仍然是把特征信息存在用户电脑上，只要用户想，还是能够清除他们的。然而下面这第三种方式就真的无法清除了。
第三种方式是直接由 ISP 厂商参与，在中途给你插入 cookie 信息。具体来说就是 ISP 厂商分析你的流量，发现是 HTTP 请求，就使用你的网络接入信息给你生成 cookie 信息。这一勾当最早是由美国 Verizon 电信公司实践的，Verizon 为了更好的服务自己的那些广告主们，用这种方式跟踪用户。虽然这种方式使得我们无法清除 cookie，但因为这种方式需要 ISP 分析发现 HTTP 流量，所以只要我们尽可能的只访问 HTTPS 服务（HTTPS Everywhere 插件能够帮助我们尽可能多的走 HTTPS 链路），还是能够有效防止被通过这种方式跟踪的。</description></item><item><title>通用网关协议 (CGI) 进化史 下篇</title><link>https://cifer76.github.io/posts/common-gateway-interface-evolution-3/</link><pubDate>Fri, 11 Jul 2014 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/common-gateway-interface-evolution-3/</guid><description>FastCGI FastCGI 和 SCGI 是比较类似的, 但 FastCGI 明显要比 SCGI 流行很多, 可以看一下参考1 中维基页面, 实现 FastCGI 的 webserver, 以及语言 binding 明显要比 SCGI 的维基页中介绍的多.
FastCGI 也有自己的官方网站, 其官方网站可以看出 FastCGI 的一系列优点 (这些优点对 SCGI 也适用):
FastCGI 够简单, 它实际只是 CGI 以及一些扩展. 如 CGI 一样, FastCGI 也是和语言无关的. 如 CGI 一样, FastCGI 进程与 webserver 的进程是隔离的, 这相比模块化的方案来说, 提高了安全性. (mod_perl, mod_php 这样的方案, 如果模块中有 bug, 会导致 webserver 受影响) 如 CGI 一样, FastCGI 并不是与 webserver 的架构结合在一起的, 而模块化的方式, 是与 webserver 的架构结合在一起的. 当然, 除了兼具 CGI 的好处, FastCGI 还具备以下两点主要好处:</description></item><item><title>通俗地解释 CGI, FastCGI, php-fpm 之间的关系</title><link>https://cifer76.github.io/posts/cgi-fastcgi-php-fpm/</link><pubDate>Wed, 02 Jul 2014 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/cgi-fastcgi-php-fpm/</guid><description>这要了解一点万维网 (WWW) 的历史, 才能更好地了解个中关系.
早期的网站基本都是静态的, 那时候的 web server 几乎所有工作就是给访问者提供静态资源, 网站与访问者之间缺乏交互. 后来随着 WWW 的发展网站变得交互性强了起来, 交互性强了也意味着 web server 端的业务逻辑复杂了起来, 不再是简单地解析 url, 定位并返回用户请求的资源, 而是要处理很多用户请求的动态资源以及许多复杂的业务, 这些工作都交给 web server 来做是不现实的, 因为单纯作为 web server 是不知道也不应该关注业务的.
于是 CGI 出现了, 它使得 web server 可以把复杂的业务逻辑交给 cgi 脚本程序来做, CGI 协议定义了 web server 与 cgi 程序之间通信的 context, web server 一收到动态资源的请求就 fork 一个子进程调用 cgi 程序处理这个请求, 同时将和此请求相关的 context 传给 cgi 程序, 像是 path_info, script path, request method, remote ip 等等&amp;hellip;
但是显然每次来个请求 web server 就去 fork 子进程是很低效的, 在网站访问量逐渐增大时网站性能问题日益凸显.</description></item><item><title>简述网页出现乱码的原因</title><link>https://cifer76.github.io/posts/garbled/</link><pubDate>Fri, 07 Dec 2012 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/garbled/</guid><description>网页的编码究其根源是由存在硬盘里的 HTML 源文件的编码所决定的, 源文件的编码则由编辑器所影响, HTML 源文件中的这个标签用来告诉浏览器源文件的编码是什么, 这里指定的编码如果和原文件实际的编码不一样, 就会引发浏览器显示乱码的问题.
&amp;lt;meta http-equiv=&amp;quot;Content-type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt; 比如我们用 vim 创建原文件并显式指定这个源文件的编码为 gbk, 这样一来 vim 会以 gbk 的格式存储源文件到硬盘上, 等到浏览器访问网页的时候, 这个源文件被从硬盘加载, 浏览器发现标签里的 utf-8, 就会以 utf-8 格式解码源文件剩下的内容, 显然这时解析出来的会是乱码. 而浏览器之所以能够解析出 meta 标签的内容, 是因为英文字符在 gbk 和 utf-8 编码中的格式是一样的.</description></item><item><title>通用网关协议 (CGI) 进化史 中篇</title><link>https://cifer76.github.io/posts/common-gateway-interface-evolution-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/common-gateway-interface-evolution-2/</guid><description>CGI 由于前面提到的性能问题, 越来越无法满足大多数网站的要求. 于是, FastCGI 和 Simple CGI 出现了.
Simple CGI (SCGI) Simple CGI 简称 SCGI, 和 FastCGI 一起, 是为了解决原始 CGI 的性能问题而出现的. 它们的解决方式和 &amp;ldquo;将脚本程序解释器嵌入 webserver (如 mod_php, mod_python&amp;rdquo; 不同, 它们的解决方式是创建一个 long-running 的后台进程, 以处理 webserver 的 forward 过来的请求.
当然, webserver 上仍然需要实现 FastCGI 或者 SCGI 协议的, apache 有 mod_fastcgi/mod_fcgid, lighttpd 也有 mod_fastcgi 和 mod_scgi.
SCGI 和 FastCGI 基本是一样的, 除了 SCGI 比 FastCGI 更容易实现 &amp;mdash; 正如其名字所暗示的那样.
下面看一下在各个 webserver 对 SCGI 的支持情况与配置方式.
Apache 最初, Apache 的模块 mod_scgi 负责实现 scgi 协议, 这个模块不是 Apache 自己开发的, 似乎是 python 用户组开发的, 因为官网就是 python 站上 (参考1).</description></item><item><title>通用网关协议 (CGI) 进化史 番外篇</title><link>https://cifer76.github.io/posts/common-gateway-interface-evolution-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cifer76.github.io/posts/common-gateway-interface-evolution-4/</guid><description>WSGI 在 python 大红大紫的今天, 除了 FastCGI, 我们听到的最多的可能就要数 WSGI 了, 那么 WSGI 又是啥呢? 它和 CGI, SCGI, FastCGI 又有什么关系呢?
你应该能猜得到, 既然 WSGI 也归到了 &amp;ldquo;通用网关协议 (CGI) 进化史&amp;rdquo; 这一系列里面, 那么 WSGI 和 CGI 肯定也是有点关系的.
WSGI 是专为 python 设计的协议, 其包装了 FastCGI 协议, WSGI server 一般也都能够作为 SCGI server, 或者 FastCGI server 运行.
如果说 FastCGI 传递信息时用的是一种底层字节流的形式, 那么 WSGI 就是将这字节流结构化为 python 对象, 这使得在 python 中进行 web 开发时, 你只要写一个文件上传的表单, 通过 WSGI 你就能直接获得这个文件的对象, 而不必自己去读取 HTTP 请求体来接收上传的文件.
Python 养了很多的框架, 如 Zope, Quixote, Webware, SkunkWeb, PSO 以及 Twisted Web.</description></item></channel></rss>
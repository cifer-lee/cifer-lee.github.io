<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on 狂想曲</title><link>/categories/linux/</link><description>Recent content in Linux on 狂想曲</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 02 May 2015 11:27:31 +0000</lastBuildDate><atom:link href="/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>PAM, su 以及 wheel 用户组</title><link>/posts/pam-su-wheel-group/</link><pubDate>Sat, 02 May 2015 11:27:31 +0000</pubDate><guid>/posts/pam-su-wheel-group/</guid><description>在我的 gentoo 系统下, su 使用 pam 模组, 要求只有处于 wheel 用户组的普通用户才能够使用 su 切换到 root 用户的权限. 如果你查看 /etc/pam.d/su, 可以看到下面这一行:
auth required pam_wheel.so use_uid 但是 GNU su 不支持 wheel 用户组, 也就是说, 如果你使用的是 GNU su, 那么当你 (普通用户) 执行 GNU su 来切换到 root 权限时, GNU su 不会检查你是否是 wheel 用户组的一员, 只要你给出了 root 用户的密码就能够切换成功.
这是怎么实现的呢, 可以看出, 上面那一行 pam 规则中, flag 值用的是 required, required 这个值在这里表示不管 pam_wheel.so 模块的检查结果是成功还是失败, 后续的检查都会继续运行下去, 那么 GNU su 只要忽略 pam_wheel.so 的检查结果就可以了. 而其他的 su 实现, 则不会忽略 pam_wheel.</description></item><item><title>Linux C 中如何正确的判断一个文件/目录文件是否存在</title><link>/posts/howto-detect-file-exists/</link><pubDate>Sun, 06 Apr 2014 14:59:00 +0000</pubDate><guid>/posts/howto-detect-file-exists/</guid><description>source: http://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c-cross-platform
其实不光是在 Linux 下编程, 在其他平台下我们都会有这样的需求: 我们要为应用程序创建自己的数据或者日志目录, 应用程序在每次启动时会检查文件系统中是否已经有了自己的目录, 没有的话就创建它, 有了的话就跳过这一步. 那么如何去判断文件系统中是否已经存在了要创建的目录呢?
Linux 或者 GNU C 都没有提供一个像 file_exists() 这样直观的系统调用给我们, 所以我们得通过其它的调用来达成这个目标.
实际上当我第一次要解决这个问题时, 我先 google 了一下, 这个问题在 stackoverflow 上有人问过而且非常受欢迎, 很多人对这个问题又点赞又收藏的, 自然, 这个问题也收到了不少好的答案, 这篇文章算是对这些好答案的总结和延伸.
我们先来看一个大家都应该知道的方式, 第一种方式:
fopen() fopen() 方法是流阶级的方法, 这个方法接收用户提供的文件名, 以及访问方式, 然后尝试着打开文件, 打开成功则返回 handle, 失败则返回 NULL. 因此有人提出了使用这个方法来判断指定的文件是否存在的方案:
#include &amp;lt;stdio.h&amp;gt; ... FILE *fp = NULL; fp = fopen(&amp;quot;/tmp/test/somefile&amp;quot;, &amp;quot;r&amp;quot;); if(fp) { // exists } else { // not exists } fclose(fp); 这也是 stackoverflow 上唯一一个得负分的答案, 这个方案的问题在于它没有考虑到文件权限的问题, 而 fopen() 这个函数又是如此的简单 &amp;mdash; 不管因为什么原因打开文件失败了, 它只是返回 NULL 给你, 不会提供更多的错误信息.</description></item><item><title>搞定 HP MicroServer 的 Smart Array Controller B120i 磁盘阵列, 在安装 RHEL 时</title><link>/posts/work-through-raid-in-rhel/</link><pubDate>Wed, 22 Jan 2014 09:48:00 +0000</pubDate><guid>/posts/work-through-raid-in-rhel/</guid><description>MicroServer Gen8 是 HP 服务器里较新的一个系列, 其所配备的磁盘阵列卡 &amp;mdash; Smart Array Controller B120i, 也是比较新的一种阵列卡, 目前 HP 仅提供了 RHEL, OpenSUSE, Microsoft 的驱动程序.
我们就是要在 MicroServer Gen8 上安装 RHEL6.
MicroServer Gen8 的主板上的 ROM 上搭在了一个小型的配置系统, 叫做 Intelligence Provisioning, 在这里你可以对磁盘阵列进行分区(正如 hardware raid 都会带有一个控制系统来管理自己的说法一样), 还可以配置你要安装的操作系统(不过在通过这个配置你可以安装的系统有限, 仅限于 HP 提供了阵列卡驱动的那些系统), 还带了一些系统健康状态监控的功能.
对于上述的几个可以在 Intelligence Provisoning 中配置的操作系统, MicroServer Gen8 似乎都提供了他们的安装程序, 这点比较方便, 因为在 Intelligence Provisioning 中配置好我们想安装的操作系统之后, 重启机器就回进入这个操作系统的安装界面, 然后你只需要提供操作系统的镜像就可以继续你的安装. 但是 Gen8 预置的 RHEL 操作系统安装程序却是有一个严重的不如人意的地方, 稍候我会说明这一点.
众所周知, 安装软件时, 一般来说这个软件会提供一个安装程序, 我记得 windows 下以前最火的制作安装程序的软件叫 InstallShield 不知现在还是不是最火的, 使用这个软件就可以制作出那种傻瓜化的一路下一步的软件安装程序, 而 linux 下的安装程序, 应该就得算各种包管理系统或者是.</description></item></channel></rss>
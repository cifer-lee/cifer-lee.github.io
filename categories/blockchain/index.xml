<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blockchain on 编程笔记</title><link>https://cifer97.github.io/categories/blockchain/</link><description>Recent content in Blockchain on 编程笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 16 Sep 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer97.github.io/categories/blockchain/index.xml" rel="self" type="application/rss+xml"/><item><title>Bitshares 中的账户与权限个人理解</title><link>https://cifer97.github.io/posts/bitshares-account-mechanism/</link><pubDate>Sat, 16 Sep 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/bitshares-account-mechanism/</guid><description>单一账户模型 在这个模型下, 我们提供一个登录名以及密码, 系统会根据登录名+密码生成确定的私钥, 所以用这种模式创建的账户, 可以在任何设备上用登录名+密码登录.
钱包模型 钱包模型的好处是, 钱包可以包含多个账户, 这些个账户的私钥全都保存在此钱包中, 用钱包在任何地方登陆都能获得你所有的账户. 但是有个不方便的地方是登录需要使用钱包文件, 不如直接输登录名密码来得方便 (较新的客户端可以用 brainkey 恢复钱包, 但 brainkey 还是没有输入登录名密码方便).
钱包模型下支持给钱包中的账户新创建三个私钥, 创建时需要提供一个密码, 新建的私钥是根据账户名+密码生成的, 三个私钥分别控制着账户的三个权限 (具体见下文). 如此一来, 钱包中的这个账户就变得好像和单一账户模型中申请的账户一样了. 这个功能能够方便我们使用账户名和密码在其他设备上登录我们的账号.
权限 bitshares 天然对多重签名有良好的支持, 其设计为将每个账户的花钱的权限分离出来, 我们可以为某个账户配置更多的私钥或者其它账户, 并为这些私钥或者其他账户设定不同的权重, 同时设定一个阈值, 要花这个账户的钱, 需要权重大于设定的阈值才可以.
bitshares 目前划分了三级与账户相关的权限, 上面说的花钱的权限是一级. 另外还有 memo 权限, 创建交易时附加的 memo 可以用单独的私钥签名, 这项权限目前还不支持多重签名, 貌似也没必要. 最后一项是最重要的权限, 即对整个账户的控制权, 这个权限能够修改账户的各种信息, 配置, 包括权限配置, 这项权限当然也是支持多重签名的.
参考 官方这两个链接值得一读
http://docs.bitshares.org/bitshares/user/account.html http://docs.bitshares.org/bitshares/user/account-permissions.html</description></item><item><title>比特币地址, 公钥与私钥的格式以及如何保证比特币不丢失</title><link>https://cifer97.github.io/posts/what-is-bitcoin-address-how-to-protect-it/</link><pubDate>Fri, 01 Sep 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/what-is-bitcoin-address-how-to-protect-it/</guid><description>我们知道在公钥加密体系中, 由私钥推出公钥很容易反过来却是不可能的, 借助一些伟大的数学算法可以实现这一特性, 比特币使用的算法叫做椭圆曲线算法.
在比特币中私钥就是一个 256bit 的数字, 得到这个数字的方法有很多, 最简单的就是随机法, 比如掷硬币 256 次, 将结果作为私钥. 得到了私钥之后对其执行椭圆曲线算法, 我们就得到了对应的公钥, 公钥是 一对 坐标: (x, y) 以及 (x, -y), 其中 x, y 都是 256bit 的数字, 所以公钥的长度有两种情况:
512bit - 同时记录了 x, y 256bit - 记录 x 以及 y 的符号, 这需要一点点额外的运算来算出 y 公私钥编码 如果用 2 进制, 即便是 16 进制来写出公钥或私钥的话, 那结果是很长的, 比较不方便. 因此我们所见到的公私钥一般都是格式化过或压缩过的.
从 bitcoin core 开始, 比特币客户端使用的格式有 WIF (Wallet Import Format) 以及 WIF-compressed. WIF 格式使用 Base58 编码公私钥.</description></item><item><title>Solidity 的编译器们</title><link>https://cifer97.github.io/posts/compilers-of-solidity/</link><pubDate>Sun, 20 Aug 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/compilers-of-solidity/</guid><description>solidity 是当下 ethereum 最流行的智能合约开发语言, 语法类似于 javascript. 要使用它写智能合约的话, 我们还需要一个编译器, 用来将 solidity 的代码编译为 EVM 字节码.
solidity 的编译器有多种实现, 下面可以一起看一看.
solc 一般说到 solc 指的都是 ethereum 官方实现的 cpp 版本的 solidity 编译器, 其项目源代码位于 https://github.com/ethereum/solidity. 按照我以往对编译器的印象, 本以为 solc 一定也是像 gcc 那样的庞然大物, 结果发现完全不是, solidity 编译器实际上是个体积很小很简单精巧的工具, 项目源代码算上注释总共也就才 6w 多行. 我们可以克隆这个仓库, 然后自行构建它, 构建出来的主要目标文件就是 solc.
solcjs solidity 的官方文档中还介绍了使用 npm/nodejs 安装的方法. npm install -g solc 之后会得到一个 solcjs 命令, 本来我以为这个 solcjs 实际上是 solc 的前端, 查了一下发现完全不是的: https://github.com/ethereum/solidity/issues/725#issuecomment-233227534, solcjs 本身就是整个 solidity 编译器, solcjsi 项目代码在 https://github.com/ethereum/solc-js, 这个项目是借助 Emscripten 工具直接把 cpp 的代码重写成了 javascript 代码, 于是得到了一个完整的 javascript 版的 solidity 编译器, 我们可以在 nodejs 中直接 require ('solc') 使用它.</description></item></channel></rss>
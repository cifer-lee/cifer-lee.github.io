<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming on 编程笔记</title><link>https://cifer97.github.io/categories/programming/</link><description>Recent content in Programming on 编程笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 10 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://cifer97.github.io/categories/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>对解释器与 JIT 的一点思考</title><link>https://cifer97.github.io/posts/jit/</link><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/jit/</guid><description>我一直知道解释器与编译器的区别. 编译器是事先将代码编译成机器码, 然后直接送进内存让 cpu 执行, 解释器则是解释执行代码, 可能会将代码先转换成一种中间码, 但我一直有一个误区就是解释器在解释执行的时候会把源代码</description></item><item><title>对协程的一点认识</title><link>https://cifer97.github.io/posts/coroutine/</link><pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/coroutine/</guid><description>协程的调度 我们知道线程是 CPU 的基本调度单元，线程调度靠的是时钟中断. 协程是执行于线程之内的更细粒度的执行单元，他的调度无法依赖时钟中断，而是要靠一个用户态的调度器，这个调度器可以是抢占式或非抢占式，抢占</description></item><item><title>C++ 的左右值与左右值引用</title><link>https://cifer97.github.io/posts/c-plus-plus-reference/</link><pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/c-plus-plus-reference/</guid><description>左值与右值 C++ 中左值和右值的概念来源于 C, 在 C 中左值和右值的区别很简单, 能出现在赋值号左侧的就是左值, 否则就是右值. 比如变量是左值, 字面常量或者 const 定义的常量是右值. 然而在 C++ 中, 左值和右值的区别就不再是那么</description></item><item><title>如何在应用层控制最大客户端连接</title><link>https://cifer97.github.io/posts/controlling-client-connections/</link><pubDate>Fri, 23 Feb 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/controlling-client-connections/</guid><description>当有客户端连接, 而程序中没有去处理时, select 就回持续不断的返回这个文件描述符可写, 例如, 下面是我以前写的一段有 bug 的程序: int csocks[MAX_CONNECTION]; memset(csocks, -1, MAX_CONNECTION * sizeof(int)); FD_SET(sock, &amp;amp;rset); while(1) { if (select(FD_SETSIZE, &amp;amp;rset, NULL, NULL, NULL) &amp;lt;= 0) { return ; } if (FD_ISSET(sock, &amp;amp;rset)) { // looking for an unused socket for (int i = 0 ; i &amp;lt; MAX_CONNECTION;</description></item><item><title>C 语言宏的展开与字符串化宏和符号连接宏</title><link>https://cifer97.github.io/posts/c-macro/</link><pubDate>Tue, 20 Feb 2018 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/c-macro/</guid><description>C 语言由于没什么高级的特性, 所以现有的特性被玩的各种精. 宏展开就是很值得品味的部分. 递归展开问题 宏定义语句是这样的: #define identifier token-sequence 在具体的宏展开过程中, 遇到标识符时, 此标识符会整个的被使用 token-sequence 展开, 如果 token-sequence 中还包</description></item><item><title>深入解读同步/异步 IO 编程模型</title><link>https://cifer97.github.io/posts/io-programming/</link><pubDate>Mon, 06 Nov 2017 00:00:00 +0000</pubDate><guid>https://cifer97.github.io/posts/io-programming/</guid><description>所谓 &amp;ldquo;同步&amp;rdquo; 和 &amp;ldquo;异步&amp;rdquo; 是从调用者的角度来说的. 如果调用者不得不等待 IO 完成才能执行后续的工作, 那就是同步; 否则, 就是异步. 这是我对 &amp;ldquo;同步&amp;rd</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on 编程笔记</title><link>https://cifer97.github.io/categories/algorithm/</link><description>Recent content in Algorithm on 编程笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 22 Oct 2016 17:24:36 +0000</lastBuildDate><atom:link href="https://cifer97.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>二叉树递归遍历的本质以及用迭代遍历精确模拟递归遍历</title><link>https://cifer97.github.io/posts/binary-tree-traversal/</link><pubDate>Sat, 22 Oct 2016 17:24:36 +0000</pubDate><guid>https://cifer97.github.io/posts/binary-tree-traversal/</guid><description>递归遍历是实现深度优先遍历的既直观又简单的方式, 二叉树递归遍历的本质其实就是在不断的压栈与出栈, 明白了这一道理之后就很容易借助栈结构来将递归遍历转换成迭代遍历. void traverse(struct TreeNode *root) { if (root) { /* 1 */ traverse(root-&amp;gt;left); /* 2 */ traverse(root-&amp;gt;right); /* 3 */ }</description></item></channel></rss>